#!/usr/bin/env ruby

require "cheetah"
require "thor"
require "tsort"
require "yaml"

BASE_DIR = File.expand_path(File.dirname(__FILE__))

DATA_DIR    = "#{BASE_DIR}/data"
STUBS_DIR   = "#{BASE_DIR}/stubs"
PATCHES_DIR = "#{BASE_DIR}/patches"

ERROR_FILE = "#{BASE_DIR}/error.log"

module Messages
  MAX_MESSAGE_WIDTH = 70

  class << self
    def start(message)
      print message

      @last_message_size = message.size
    end

    def finish(status)
      spaces = if @last_message_size < MAX_MESSAGE_WIDTH
        " " * (MAX_MESSAGE_WIDTH - @last_message_size)
      else
        ""
      end

      puts spaces + status
    end

    def info(message)
      puts message
    end
  end
end

# Hash: String -> YastModule
$yast_modules = Hash.new do |hash, missing_key|
  #report misspelled modules instead of producing nil
  raise "Unknown yast module #{missing_key}"
end

class YastModule

  WORK_DIR   = "work"
  RESULT_DIR = "result"
  OBS_DIR = "build_service"
  OBS_PROJECT = "YaST:Head:ruby"

  attr_reader :name,
    :work_dir,
    :result_dir,
    :obs_dir,
    :deps,
    :exports,
    :excluded,
    :moves

  def initialize(name, data, config)
    @name       = name
    @config     = config
    @work_dir   = "#{@config["yast_dir"]}/#{WORK_DIR}/#@name"
    @result_dir = "#{@config["yast_dir"]}/#{RESULT_DIR}/#@name"
    # Not suffixed with @name as it does not match (usuall yast2-#{name} )
    @obs_dir    = "#{@config["yast_dir"]}/#{OBS_DIR}"
    @deps       = data.delete("deps") || []
    @exports    = data.delete("exports") || ["src"]
    @excluded   = data.delete("excluded") || []
    @moves      = data.delete("moves") || []

    if !data.empty?
      puts "WARNING: Unknown keys in #{name}.yml: #{data.keys.join(", ")}."
    end
  end

  def transitive_deps
    deps_of_deps = deps.map { |d| $yast_modules[d].transitive_deps }
    depth_first_deps = deps_of_deps.reduce([], :+) + deps
    # Note that they come out topologically sorted
    # because uniq takes the first object.
    depth_first_deps.uniq
  end

  # can only be called once all $yast_modules have been initialized
  def check_missing_work(yast_module_names)
    missing = yast_module_names.reject do |d|
      File.exists?($yast_modules[d].work_dir)
    end
    if ! missing.empty?
      raise "These dependencies do not have a working directory; convert them first: #{missing.join(", ")}"
    end
  end

  def convert
    check_missing_work(deps)
    File.exists?(work_dir) ? update : clone
    restructure
    patch
    res = compile
    # in case of error do not continue with submit
    if !res[:error_ybc].zero? ||
        !res[:error_y2r].zero? ||
        !res[:error_ruby].zero? ||
        !res[:error_other].zero?
      return res
    end

    generate_makefiles
    package

    res
  end

  def clone
    FileUtils.rm_rf(work_dir)

    Cheetah.run "git", "clone", "git://github.com/yast/yast-#@name.git", work_dir
  end

  def update
    reset
    pull
  end

  def pull
    Dir.chdir work_dir do
      Cheetah.run "git", "pull"
    end
  end

  def patch
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"
    return unless File.exists?(patch_file)

    Dir.chdir work_dir do
      Cheetah.run "git", "apply", patch_file
    end
  end

  def genpatch
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"

    FileUtils.rm_rf patch_file

    Dir.chdir work_dir do
      output = Cheetah.run "git", "diff", :stdout => :capture
      # git fails to apply empty file, so don't create it
      return if output.empty?

      File.open(patch_file, "w") do |f|
        f.write output
      end
    end
  end

  def compile
    clean_previous_compilation
    prepare_result_dir

    @counts = {
      :ok          => 0,
      :excluded    => excluded.size,
      :error_ybc   => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }

    Dir.chdir work_dir do
      failed_files = compile_modules
      convert_ycp failed_files
    end

    @counts
  end

  def exported_module_paths
    exports.map { |e| "#{work_dir}/#{e}/modules" }
  end

  def exported_include_paths
    exports.map { |e| "#{work_dir}/#{e}/include" }
  end

  def reset
    Dir.chdir work_dir do
      Cheetah.run "git", "reset", "--hard", "HEAD"

      output = Cheetah.run "git", "status", "--short", :stdout => :capture
      output.split("\n").each do |line|
        if line =~ /^\?\?\s+(.*)$/
          FileUtils.rm_rf $1
        else
          raise "Unknown git file status: #{line}"
        end
      end
    end
  end

  def restructure
    puts "WARNING: No 'moves' section found in #{name}.yml" if moves.empty?
    Dir.chdir work_dir do
      moves.each do |move|
        FileUtils.mkdir_p move["to"]

        Dir.glob("#{work_dir}/#{move["from"]}") do |file|
          # We want the moves stored in git index. This way the "genpatch"
          # command creates patch against state after restructuring, not
          # before it.
          Cheetah.run "git", "mv", file, move["to"]
        end
      end
    end
  end

  def generate_makefiles
    exports.each do |export_dir|
      dir = "#{result_dir}/#{export_dir}"

      Dir["#{dir}/**/Makefile.am"].each do |file|
        FileUtils.rm file
      end

      File.open("#{dir}/Makefile.am", "w") do |file|
        dist_variables = []

        file.puts "# Sources for #{name}"
        Dir.chdir dir do
          sections = MAKEFILE_DESCRIPTION.map do |section|
            result = section.dup
            result[:files] = Dir[section[:glob]]

            result
          end

          sections.reject! { |section| section[:files].empty? }

          sections = sections.map { |section| split_section(section) }.reduce(&:+)

          sections.each do |section|
            file.write makefile_entry(section[:key_line] || section[:key], section[:values])

            dist_variables << section[:key]
          end

          dist_value = dist_variables.map { |v| "$(#{v})" }.join(" ")
          file.write "\nEXTRA_DIST = #{dist_value}\n\n"
          file.write 'include $(top_srcdir)/Makefile.am.common'
        end
      end
    end
  end

  def package
    Dir.chdir result_dir do
      Cheetah.run "make", "-f", "Makefile.cvs" # TODO will not work for cmake based ones
      Cheetah.run "make"
      Cheetah.run "make", "package-local", "CHECK_SYNTAX=false"
    end

    package_name = File.read("#{result_dir}/RPMNAME").chomp

    FileUtils.mkdir_p obs_dir
    Dir.chdir obs_dir do
      package_obs_dir = "#{obs_dir}/#{OBS_PROJECT}/#{package_name}"

      create_obs_package_dir!(package_name) unless File.exists?(package_obs_dir)

      Dir["#{result_dir}/package/*"].each do |file|
        # for last three arguments keep defaults except last that we switch to
        # overwrite file in destrination
        FileUtils.copy_entry file, "#{package_obs_dir}/#{File.basename(file)}", false, false, true
      end
    end
  end

  private

  # cwd must be obs_dir
  def create_obs_package_dir!(package_name)
    first = true
    begin
      Cheetah.run "osc", "co", OBS_PROJECT, package_name
    rescue Cheetah::ExecutionFailed
      # probably it is not created yet, so lets create it
      if first
        first = false
        create_package_in_obs package_name
        retry
      end

      raise
    end
  end

  def create_package_in_obs(package_name)
    ENV["EDITOR"] = "ed"
    # just add description via ed as meta pkg invoke editor
    ed_command = <<EOS
      # enable error reporting
      H
      # title is required
      # comma: all lines; s: substitute
      ,s/<title>/<title>YaST module converted to ruby/
      # write
      w
      # quit
      q
EOS

    Cheetah.run "osc", "meta", "pkg", OBS_PROJECT, package_name, "-e", :stdin => StringIO.new(ed_command)
  end

  def makefile_entry(key, values)
    "\n#{key} = \\\n  " + values.join(" \\\n  ") + "\n"
  end

  MAKEFILE_DESCRIPTION = [
    {
      :glob     => 'modules/**/*\.{ycp,ybc,rb,py,pl,pm,sh}',
      :key      => 'module_DATA',
      :dir_var  => '@moduledir@'
    },
    {
      :glob     => 'clients/**/*\.{ycp,rb,py,pl,sh,pm}',
      :key      => 'client_DATA'
    },
    {
      :glob     => 'include/**/*\.{ycp,rb,py}',
      :key      => 'ynclude_DATA',
      :dir_var  => '@yncludedir@'
    },
    {
      :glob     => "scrconf/*\.scr",
      :key      => "scrconf_DATA"
    },
    {
      :glob     => "servers_non_y2/*",
      :key      => "agent_SCRIPTS"
    },
    {
      :glob     => "autoyast-rnc/*.rnc",
      :key      => "schemafiles_DATA",
      :key_line => "schemafilesdir = $(schemadir)/autoyast/rnc\nschemafiles_DATA"
    },
    {
      :glob     => "bin/*",
      :key      => "ybin_SCRIPTS"
    },
    {
      :glob     => "data/*",
      :key      => "ydata_DATA"
    },
    {
      :glob     => "desktop/*",
      :key      => "desktop_DATA"
    },
    {
      :glob     => "fillup/*",
      :key      => "fillup_DATA"
    }
  ]

  def split_section(section)
    # Group section by subdirectories it includes.
    # Note this means that we ignore the first directory in the path.
    #
    # Example:
    #
    #   [ "modules/Language.rb", "modules/YAPI/LANGUAGE/pl"]
    #
    # ends up as 
    #
    #   {
    #     [] => ["modules/Language.rb"]
    #     ["YAPI"] => ["modules/YAPI/LANGUAGE/pl"]
    #   }
    groups = section[:files].group_by { |f| f.split('/')[1..-2] }

    i = 0
    groups.map do |subdir, values|
      # The key includes a name and its type separated by underscore,
      # e.g. ynclude_DATA or ybin_SCRIPT. We construct unique group name and key
      # from the name (not the type).
      key_parts = section[:key].split('_')
      key_type = key_parts.pop
      key_name = key_parts.join("_")

      key_name = key_name + i.to_s if i > 0

      res = {
        :values => values,
        :key    => "#{key_name}_#{key_type}"
      }

      # For the schemafiles section we already have special key_line, so we use
      # it. There should be no subdirs there, so it is not a problem.
      res[:key_line] = section[:key_line] if section[:key_line]

      # If it is not a subdir and the first element, then keep it as it was
      # (common case).
      if subdir.size > 0 || i > 0
        raise "Unexpected subdir #{subdir.join("/")} for key #{key_name}" unless section[:dir_var]

        res[:key_line] = "#{key_name}dir = #{section[:dir_var]}/#{subdir.join("/")}\n#{res[:key]}"
      end

      i += 1

      res
    end
  end

  def module_paths
    # The lazy loading is needed because the dependencies may not be fully
    # initialized when "initialize" is called on this module.
    unless @module_paths 
      @module_paths = [STUBS_DIR] + exported_module_paths
      transitive_deps.each do |dependency|
        @module_paths.concat $yast_modules[dependency].exported_module_paths
      end
    end
    @module_paths
  end

  def include_paths
    # The lazy loading is needed because the dependencies may not be fully
    # initialized when "initialize" is called on this module.
    unless @include_paths
      @include_paths = [STUBS_DIR] + exported_include_paths
      transitive_deps.each do |dependency|
        @include_paths.concat $yast_modules[dependency].exported_include_paths
      end
    end
    @include_paths
  end

  def handle_exception(e, phase, file)
    raise if e.is_a? Interrupt

    if ! e.is_a? Cheetah::ExecutionFailed
      phase = :other
    end
    Messages.finish "ERROR(#{phase})"
    @counts["error_#{phase}".to_sym] += 1
    log_error(file, e)
  end

  def compile_modules
    failed_files = []
    # list of full paths
    ordered_modules = BuildOrder.new(exports).ordered_modules

    ordered_modules.each do |file|
      begin
        Messages.start "  . #{file}"
        create_ybc file
        Messages.finish "OK"
      rescue Exception => e
        handle_exception(e, :ybc, file)
        failed_files << file
      end
    end

    failed_files
  end

  def convert_ycp failed_files
    Dir["**/*.y{cp,h}"].each do |file|
      next if excluded.include?(file)
      next if failed_files.include?(file)

      Messages.start "  * #{file}"

      work_file = "#{work_dir}/#{file}"
      FileUtils.rm "#{result_dir}/#{file}"
      result_file = "#{result_dir}/#{file}".sub(/\.y(cp|h)$/, ".rb")

      begin
        # This makes private symbols in modules visible. Needed by some
        # testsuites.
        ENV["Y2ALLGLOBAL"] = "1"

        create_rb  work_file, result_file
      rescue Exception => e
        handle_exception(e, :y2r, work_file)
        next
      end

      begin
        check_rb result_file
      rescue Exception => e
        handle_exception(e, :ruby, work_file)
        next
      end

      Messages.finish "OK"
      @counts[:ok] += 1
    end
  end

  def clean_previous_compilation
    FileUtils.rm_rf result_dir
    Dir["#{work_dir}/**/*.ybc"].each do |file|
      FileUtils.rm file
    end
  end

  def prepare_result_dir
    FileUtils.mkdir_p File.dirname(result_dir)
    FileUtils.copy_entry(work_dir, result_dir)
  end

  def create_ybc(file)
    cmd = [@config["ycpc"], "--no-std-includes", "--no-std-modules"]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << "-c" << file

    Cheetah.run cmd
  end

  def create_rb(file, output_file)
    cmd = [@config["y2r"]]
    cmd << "--ycpc" << @config["ycpc"]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    cmd << "--module-path" << File.dirname(file)
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << "--include-path" << File.dirname(file)
    cmd << file
    cmd << output_file

    Cheetah.run cmd
  end

  def check_rb(file)
    Cheetah.run "ruby", "-c", file
  end

  def log_error(file, e)
    File.open(ERROR_FILE, "a") do |f|
      f.puts file
      f.puts "-" * file.size
      f.puts
      if e.is_a?(Cheetah::ExecutionFailed)
        f.puts e.stderr
      else
        f.puts e.message
        e.backtrace.each { |l| f.puts l }
      end
      f.puts
    end
  end

end

# based on ycpmakedep script https://github.com/yast/yast-devtools/blob/master/devtools/bin/ycpmakedep
class BuildOrder

  class Source
    attr :name                    # name
    attr :full_path               # string
    attr :imports                 # list of names
    attr :includes                # list of names

    # Parse the file.
    # imports and includes still contain references outside this package,
    # but there are no duplicates
    def initialize(name, full_path)
      @name = name
      @full_path = full_path
      lines = ::File.readlines @full_path
      @imports =  direct_imports(lines).uniq
      @includes = direct_includes(lines).uniq
    rescue ArgumentError => e
      if e.to_s =~ /invalid byte sequence/
        raise e, e.message + "; offending file: #{@full_path}"
      end
      raise e
    end

    # Can be called once we know about all local modules and includes
    def filter_outside_references(is_local_module_proc, is_local_include_proc)
      imports.keep_if(&is_local_module_proc)
      includes.keep_if(&is_local_include_proc)
    end

  private
    # return ["Report", "Popup", "FIXME: Foo::Bar or Foo/Bar"]
    def direct_imports(lines)
      import_lines = lines.grep(/^\s*import[\s"\(]/)
      import_lines.map do |line|
        line.chomp!
        line.sub!(/^\s*import[^"]*"([^"]+)".*$/, '\\1')
        line.sub!(/\.ycp$/, "")
        line
      end
    end

    # return ["lan/dialogs", "lan/routines"]
    def direct_includes(lines)
      include_lines = lines.grep(/^\s*include[\s"\(]/)

      include_lines.map do |line|
        line.chomp!
        line.sub!(/^\s*include[^"]*"([^"]+)".*$/, '\\1')
        line.sub!(/\.y(cp|h)$/, "")
        line
      end
    end
  end

  # Distinguish them because we only compile modules,
  # and there are even cycles that are ok because they consist of
  # a module-include pair
  class Module < Source
  end

  class Include < Source
  end

  # @modules  Hash: name => Source
  # @includes Hash: name => Source
  def initialize(source_dirs)
    @modules  = find_modules source_dirs
    @includes = find_includes source_dirs
    filter_outside_references
  end

  def ordered_modules
    tsorted_modules = tsort_breaking_pair_cycles.select do |source|
      source.is_a? Module
    end

    tsorted_modules.map { |source| source.full_path }
  end

  private

  def find_modules(source_dirs)
    modules = {}

    source_dirs.each do |dir|
      Dir["#{dir}/modules/**/*.ycp"].each do |file|
        relative_path = file.sub(/#{Regexp.escape(dir)}\/modules\//, "")
        module_name = relative_path.sub(/\.ycp$/, "")

        modules[module_name] = Module.new(module_name, file)
      end
    end

    modules
  end

  def find_includes(source_dirs)
    includes = {}

    source_dirs.each do |dir|
      Dir["#{dir}/include/**/*.y{cp,h}"].each do |file|
        relative_path = file.sub(/#{Regexp.escape(dir)}\/include\//, "")
        include_name = relative_path.sub(/\.y(cp|h)$/, "")

        includes[include_name] = Include.new(include_name, file)
      end
    end

    includes
  end

  include TSort

  def each_source(&block)
    @modules.each_value(&block)
    @includes.each_value(&block)
  end
  alias :tsort_each_node :each_source

  def tsort_each_child(node, &block)
    node.imports.each  { |name| block.call(@modules[name])  }
    node.includes.each { |name| block.call(@includes[name]) }
  end

  # remove items from modules and includes that refer outside this package
  def filter_outside_references
    is_local_module  = lambda {|m| @modules.has_key?(m) }
    is_local_include = lambda {|i| @includes.has_key?(i) }
    each_source do |f|
      f.filter_outside_references(is_local_module, is_local_include)
    end
  end

  # There may be a dependency cycle which is harmless,
  # because we only care that the subgraph over *modules* is acyclical.
  # That is, cycles are only a problem if they contain
  # more than one include or more than one module.
  # Therefore, we will break cycles consisting of module-include pairs.
  def tsort_breaking_pair_cycles
    each_strongly_connected_component do |component|
      next if component.size == 1
      if component.all? {|source| source.is_a? Include}
        # YCP parser breaks include cycles
        component.last.includes.delete component.first.name
        next
      end
      modules = component.find_all {|source| source.is_a? Module}
      if modules.size > 1
        raise TSort::Cyclic.new("Cycle involving 2 modules: #{component.inspect}")
      end
      # Now we have a component of one module and some includes,
      # with possibly multiple cycles in it.
      # Discard all dependencies leading from the module.
      mod = modules.first
      mod.includes.each do |i|
        puts "Broke a cyclic dependencies between #{mod.name} and #{i}."
      end
      mod.includes.clear
    end
    # all harmless cycles are broken; run for real
    tsort
  end
end

class CLI < Thor

  class_option :debug, :type => :boolean, :desc => "verbosely log what commands are run"

  def initialize(*args)
    super *args

    if options[:debug]
      log = Logger.new(STDOUT)
      Cheetah.default_options = { :logger => log }
    end

    load_config
    load_module_data
  end

  desc "clone <module>...", "Clone module(s)"
  def clone(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Cloning", true do |mod|
      mod.clone
    end
  end

  desc "convert <module>...", "Convert module(s)"
  def convert(*module_names)
    report_results(module_names) do |mod|
      mod.convert
    end
  end

  desc "genpatch <module>...", "Store changes from work directory of module(s) into a patch"
  def genpatch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Generating patch", true do |mod|
      mod.genpatch
    end
  end

  desc "patch <module>...", "Patch module(s)"
  def patch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Patching", true do |mod|
      mod.patch
    end
  end

  desc "reset <module>...", "Revert module(s) work directory to clean state"
  def reset(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Resetting", true do |mod|
      mod.reset
    end
  end

  desc "restructure <module>...", "Change module(s) work directory structure to fit the Y2DIR scheme"
  def restructure(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Restructuring", true do |mod|
      mod.restructure
    end
  end

  desc "compile <module>...", "Compile module(s)"
  def compile(*module_names)
    report_results(module_names) do |mod|
      mod.compile
    end
  end

  desc "makefile <module>...", "Generates Makefile.am for exported dirs of module(s)"
  def makefile(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Generating Makefiles", true do |mod|
      mod.generate_makefiles
    end
  end

  desc "package <module>...", "Create packages in build service directory for module(s)"
  def package(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Packaging", true do |mod|
      mod.package
    end
  end

  private

  def report_results(module_names) # :yields: mod
    compile_stubs

    FileUtils.rm_rf(ERROR_FILE)

    counts = {
      :ok          => 0,
      :excluded    => 0,
      :error_ybc   => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }

    modules = modules_from_names(module_names)
    with_modules modules, "Compiling", false do |mod|
      module_counts = yield(mod)
      counts.keys.each { |k| counts[k] += module_counts[k] }
    end

    puts
    puts "-----"
    puts
    puts "Total OK:           #{counts[:ok]}"
    puts "Total EXCLUDED:     #{counts[:excluded]}"
    puts "Total ERROR(ybc):   #{counts[:error_ybc]}"
    puts "Total ERROR(y2r):   #{counts[:error_y2r]}"
    puts "Total ERROR(ruby):  #{counts[:error_ruby]}"
    puts "Total ERROR(other): #{counts[:error_other]}"

  end

  def compile_stubs
    Dir["#{STUBS_DIR}/*.ycp"].each do |file|
      Cheetah.run @config["ycpc"], "-c", file
    end
  end

  def load_config
    @config = YAML.load_file("#{BASE_DIR}/config.yml")
  end

  def load_module_data
    Dir["#{DATA_DIR}/*.yml"].sort.each do |file|
      name = File.basename(file, ".yml")

      $yast_modules[name] = YastModule.new(
        name,
        YAML.load_file(file) || {},
        @config
      )
    end
  end

  def module_from_cwd
    cwd = Dir.pwd
    # .../work/foo
    package = cwd[/\/#{Regexp.escape(YastModule::WORK_DIR)}\/([^\/]+)\Z/, 1]
    raise "No modules specified and current directory is not a working directory" unless package
    package
  end

  def modules_from_names(module_names)
    module_names = [ module_from_cwd ] if module_names.empty?
    module_names = $yast_modules.keys if module_names == ["all"]

    $yast_modules.values_at(*module_names)
  end

  def with_modules(modules, activity, print_status) # :yields: mod
    max_counter_size = 3 + ((Math.log10(modules.size).to_i + 1) * 2)

    modules.each_index do |i|
      message = sprintf(
        "%-#{max_counter_size}s %s",
        "[#{i + 1}/#{modules.size}]",
        "#{activity} #{modules[i].name}..."
      )

      if print_status
        Messages.start message
      else
        Messages.info message
      end

      begin
        yield modules[i]
      rescue Exception => e
        Messages.finish "ERROR" if print_status
        raise
      end

      Messages.finish "OK" if print_status
    end
  end
end

begin
  CLI.start(ARGV)
rescue Cheetah::ExecutionFailed => e
  puts
  puts "Command #{e.commands[0][0]} failed:"
  puts e.stderr
rescue Interrupt
  puts # ^C is printed already
end
