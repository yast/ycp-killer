#!/usr/bin/env ruby

require "cheetah"
require "thor"
require "yaml"

BASE_DIR = File.expand_path(File.dirname(__FILE__))

DATA_DIR    = "#{BASE_DIR}/data"
STUBS_DIR   = "#{BASE_DIR}/stubs"
PATCHES_DIR = "#{BASE_DIR}/patches"

ERROR_FILE = "#{BASE_DIR}/error.log"

module Messages
  MAX_MESSAGE_WIDTH = 70

  class << self
    def start(message)
      print message

      @last_message_size = message.size
    end

    def finish(status)
      spaces = if @last_message_size < MAX_MESSAGE_WIDTH
        " " * (MAX_MESSAGE_WIDTH - @last_message_size)
      else
        ""
      end

      puts spaces + status
    end

    def info(message)
      puts message
    end
  end
end

class YastModule

  WORK_DIR   = "work"
  RESULT_DIR = "result"

  attr_reader :name,
    :work_dir,
    :result_dir,
    :deps,
    :exports,
    :excluded,
    :moves


  def initialize(name, data, modules, config)
    @name       = name
    @data       = data
    @modules    = modules
    @config     = config
    @work_dir   = "#{@config["yast_dir"]}/#{WORK_DIR}/#@name"
    @result_dir = "#{@config["yast_dir"]}/#{RESULT_DIR}/#@name"
    @deps       = @data["deps"] || []
    @exports    = @data["exports"] || ["src"]
    @excluded   = @data["excluded"] || []
    @moves      = @data["moves"] || []
  end

  def convert
    clone
    restructure
    patch
    res = compile
    generate_makefiles

    res
  end

  def clone
    FileUtils.rm_rf(work_dir)

    Cheetah.run "git", "clone", "git://github.com/yast/yast-#@name.git", work_dir
  end

  def patch
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"
    return unless File.exists?(patch_file)

    Dir.chdir work_dir do
      Cheetah.run "git", "apply", patch_file
    end
  end

  def genpatch
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"

    FileUtils.rm_rf patch_file

    Dir.chdir work_dir do
      output = Cheetah.run "git", "diff", :stdout => :capture
      # git fails to apply empty file, so don't create it
      return if output.empty?

      File.open(patch_file, "w") do |f|
        f.write output
      end
    end
  end

  def compile
    clean_previous_compilation
    prepare_result_dir

    counts = {
      :ok          => 0,
      :excluded    => excluded.size,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }

    Dir.chdir work_dir do
      failed_files = compile_modules counts
      convert_ycp counts, failed_files
    end

    counts
  end

  def exported_module_paths
    exports.map { |e| "#{work_dir}/#{e}/modules" }
  end

  def exported_include_paths
    exports.map { |e| "#{work_dir}/#{e}/include" }
  end

  def reset
    Dir.chdir work_dir do
      Cheetah.run "git", "reset", "--hard", "HEAD"

      output = Cheetah.run "git", "status", "--short", :stdout => :capture
      output.split("\n").each do |line|
        if line =~ /^\?\?\s+(.*)$/
          FileUtils.rm_rf $1
        else
          raise "Unknown git file status: #{line}"
        end
      end
    end
  end

  def restructure
    Dir.chdir work_dir do
      moves.each do |move|
        FileUtils.mkdir_p move["to"]

        Dir.glob("#{work_dir}/#{move["from"]}", File::FNM_DOTMATCH) do |file|
          # We want the moves stored in git index. This way the "genpatch"
          # command creates patch against state after restructuring, not
          # before it.
          Cheetah.run "git", "mv", file, move["to"]
        end
      end
    end
  end

  def generate_makefiles
    exports.each do |export_path|
      path = "#{result_dir}/#{export_path}"

      Dir["#{path}/**/Makefile.am"].each do |file|
        FileUtils.rm file
      end

      File.open("#{path}/Makefile.am", "w") do |file|
        file.puts "# Sources for #{name}"
        Dir.chdir path do
          res = []
          res << generate_modules(path, file)
          res << generate_includes(path, file)
          res << generate_clients(path, file)
          res << generate_scrconf(path, file)
          res << generate_agent_impl(path, file)
          res << generate_autoyast_rnc(path, file)
          res << generate_bin(path, file)
          res << generate_data(path, file)
          res << generate_desktop(path, file)

          dist_value = res.compact.map { |v| "$(#{v})" }.join(" ")
          file.write "\nEXTRA_DIST = #{dist_value}\n\n"
          file.write 'include $(top_srcdir)/Makefile.am.common'
        end
      end
    end
  end

  private

  def makefile_entry(key, values)
    val = "#{key} = \\\n  "
    val + values.join(" \\\n  ") + "\n"
  end

  def generate_modules path, file
    values = Dir["modules/**/*\.{ycp,ybc,rb,py,pl,sh}"]
    return if values.empty?

    key_name = "module_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_clients(path, file)
    values = Dir["clients/**/*\.{ycp,rb,py,pl,sh}"]
    return if values.empty?

    key_name = "client_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_includes(path, file)
    values = Dir["include/**/*\.{ycp,rb,py}"]
    return if values.empty?

    key_name = "ynclude_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_scrconf(path, file)
    values = Dir["scrconf/*\.scr"]
    return if values.empty?

    key_name = "scrconf_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_agent_impl(path, file)
    values = Dir["servers_non_y2/*"]
    return if values.empty?

    key_name = "agent_SCRIPTS"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_autoyast_rnc(path, file)
    values = Dir["autoyast-rnc/*.rnc"]
    return if values.empty?

    # schema have special format
    key = "schemafilesdir =  $(schemadir)/autoyast/rnc\nschemafiles_DATA"
    file.write "\n"
    file.write makefile_entry(key, values)

    "schemafiles_DATA"
  end

  def generate_bin(path, file)
    values = Dir["bin/*"]
    return if values.empty?

    key_name = "ybin_SCRIPTS"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_data(path, file)
    values = Dir["data/*"]
    return if values.empty?

    key_name = "ydata_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end

  def generate_desktop(path, file)
    values = Dir["desktop/*"]
    return if values.empty?

    key_name = "desktop_DATA"
    file.write "\n"
    file.write makefile_entry(key_name, values)

    key_name
  end


  def module_paths
    # The lazy loading is needed because the dependencies may not be fully
    # initialized when "initialize" is called on this module.
    unless @module_paths 
      @module_paths = [STUBS_DIR] + exported_module_paths
      deps.each do |dependency| 
        @module_paths.concat @modules[dependency].exported_module_paths
      end
    end
    @module_paths
  end

  def include_paths
    # The lazy loading is needed because the dependencies may not be fully
    # initialized when "initialize" is called on this module.
    unless @include_paths
      @include_paths = [STUBS_DIR] + exported_include_paths
      deps.each do |dependency| 
        @include_paths.concat @modules[dependency].exported_include_paths
      end
    end
    @include_paths
  end

  def compile_modules counts
    failed_files = []
    ordered_modules = BuildOrder.ordered_modules exports

    ordered_modules.each do |file|
      begin
        create_ybc file
      rescue Exception => e
        Messages.start " * #{file}"
        Messages.finish "ERROR(other)"
        log_error(file, e)
        counts[:error_other] += 1
        failed_files << file
      end
    end

    failed_files
  end

  def convert_ycp counts, failed_files
    Dir["**/*.y{cp,h}"].each do |file|
      next if excluded.include?(file)
      next if failed_files.include?(file)

      Messages.start "  * #{file}"

      work_file = "#{work_dir}/#{file}"
      FileUtils.rm "#{result_dir}/#{file}"
      result_file = "#{result_dir}/#{file}".sub(/\.y(cp|h)$/, ".rb")

      begin
        # This makes private symbols in modules visible. Needed by some
        # testsuites.
        ENV["Y2ALLGLOBAL"] = "1"

        create_rb  work_file, result_file
      rescue Cheetah::ExecutionFailed => e
        Messages.finish "ERROR(y2r)"
        log_error(work_file, e)
        counts[:error_y2r] += 1
        next
      rescue Exception => e
        Messages.finish "ERROR(other)"
        log_error(work_file, e)
        counts[:error_other] += 1
        next
      end

      begin
        check_rb result_file
      rescue Cheetah::ExecutionFailed => e
        Messages.finish "ERROR(ruby)"
        log_error(work_file, e)
        counts[:error_ruby] += 1
        next
      rescue Exception => e
        Messages.finish "ERROR(other)"
        log_error(work_file, e)
        counts[:error_other] += 1
        next
      end

      Messages.finish "OK"
      counts[:ok] += 1
    end
  end

  def clean_previous_compilation
    FileUtils.rm_rf result_dir
    Dir["#{work_dir}/**/*.ybc"].each do |file|
      FileUtils.rm file
    end
  end

  def prepare_result_dir
    FileUtils.mkdir_p File.dirname(result_dir)
    FileUtils.copy_entry(work_dir, result_dir)
  end

  def create_ybc(file)
    cmd = [@config["ycpc"], "--no-std-includes", "--no-std-modules"]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << "-c" << file

    Cheetah.run cmd
  end

  def create_rb(file, output_file)
    cmd = [@config["y2r"]]
    cmd << "--ycpc" << @config["ycpc"]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    cmd << "--module-path" << File.dirname(file)
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << "--include-path" << File.dirname(file)
    cmd << file
    cmd << output_file

    Cheetah.run cmd
  end

  def check_rb(file)
    Cheetah.run "ruby", "-c", file
  end

  def log_error(file, e)
    File.open(ERROR_FILE, "a") do |f|
      f.puts file
      f.puts "-" * file.size
      f.puts
      if e.is_a?(Cheetah::ExecutionFailed)
        f.puts e.stderr
      else
        f.puts e.message
        e.backtrace.each { |l| f.puts l }
      end
      f.puts
    end
  end

end

# based on ycpmakedep script https://github.com/yast/yast-devtools/blob/master/devtools/bin/ycpmakedep
module BuildOrder
  def self.ordered_modules(source_dirs)
    modules = find_modules source_dirs
    includes = find_includes source_dirs

    fill_module_deps(modules, includes)
    result = ordered_modules_by_deps(modules)

    result.map { |name| modules[name][:full_path] }
  end

  private

  def self.find_modules(source_dirs)
    modules = {}

    source_dirs.each do |dir|
      Dir["#{dir}/modules/**/*.ycp"].each do |file|
        relative_path = file.sub(/#{Regexp.escape(dir)}\/modules\//, "")
        module_name = relative_path.sub(/\.ycp$/, "")

        modules[module_name] = { :full_path => file }
      end
    end

    modules
  end

  def self.find_includes(source_dirs)
    includes = {}

    source_dirs.each do |dir|
      Dir["#{dir}/include/**/*.y{cp,h}"].each do |file|
        relative_path = file.sub(/#{Regexp.escape(dir)}\/include\//, "")
        include_name = relative_path.sub(/\.y(cp|h)$/, "")

        includes[include_name] = { :full_path => file }
      end
    end

    includes
  end

  def self.extract_imported_module_files(lines)
    import_lines = lines.grep(/^\s*import[\s"\(]/)
    import_lines.map do |line|
      line.chomp!
      line.sub!(/^\s*import[^"]*"([^"]+)".*$/, '\\1')
      line.sub!(/\.ycp$/, "")
      line
    end
  end

  def self.included_files(lines)
    include_lines = lines.grep(/^\s*include[\s"\(]/)

    include_lines.map do |line|
      line.chomp!
      line.sub!(/^\s*include[^"]*"([^"]+)".*$/, '\\1')
      line.sub!(/\.y(cp|h)$/, "")
      line
    end
  end

  def self.fill_module_deps(modules, includes)
    modules.each do |name, mod|
      lines = File.readlines mod[:full_path]
      deps = extract_imported_module_files lines
      included = included_files lines
      included.each do
        next unless includes[name]
        includes[name][:deps] ||= extract_imported_module_files(File.readlines(includes[name][:full_path]))
        deps.concated includes[name][:deps]
      end
      deps = deps.select { |m| modules[m] }.uniq
      mod[:deps] = deps
    end
  end

  def self.find_module_to_process(modules, unprocessed, already_processed)
    unprocessed.find do |name|
      modules[name][:deps].all? { |dep| already_processed.include? (dep) }
    end
  end

  # It can use TSort from ruby, but its API is not much flexible.
  def self.ordered_modules_by_deps(modules)
    unprocessed = modules.keys
    processed   = []

    1.upto(unprocessed.size) do
      mod = find_module_to_process(modules, unprocessed, processed)
      raise "unresolved dependencies: #{unprocessed.inspect}" unless mod
      processed << mod
      unprocessed.delete mod
    end

    processed
  end
end

class CLI < Thor
  def initialize(*args)
    super *args

    load_config
    load_module_data
  end

  desc "clone <module>...", "Clone module(s)"
  def clone(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Cloning", true do |mod|
      mod.clone
    end
  end

  desc "convert <module>...", "Convert module(s)"
  def convert(*module_names)
    report_results(module_names) do |mod|
      mod.convert
    end
  end

  desc "genpatch <module>...", "Store changes from work directory of module(s) into a patch"
  def genpatch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Generating patch", true do |mod|
      mod.genpatch
    end
  end

  desc "patch <module>...", "Patch module(s)"
  def patch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Patching", true do |mod|
      mod.patch
    end
  end

  desc "reset <module>...", "Revert module(s) work directory to clean state"
  def reset(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Resetting", true do |mod|
      mod.reset
    end
  end

  desc "restructure <module>...", "Change module(s) work directory structure according to fit the Y2DIR scheme"
  def restructure(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Restructuring", true do |mod|
      mod.restructure
    end
  end

  desc "compile <module>...", "Compile module(s)"
  def compile(*module_names)
    report_results(module_names) do |mod|
      mod.compile
    end
  end

  desc "generate_makefile <module>...", "Generate Makefile.am for exported dirs of module(s)"
  def generate_makefile(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Generating Makefiles", true do |mod|
      mod.generate_makefiles
    end
  end

  private

  def report_results(module_names)
    compile_stubs

    FileUtils.rm_rf(ERROR_FILE)

    counts = {
      :ok          => 0,
      :excluded    => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }

    modules = modules_from_names(module_names)
    with_modules modules, "Compiling", false do |mod|
      module_counts = yield(mod)
      counts.keys.each { |k| counts[k] += module_counts[k] }
    end

    puts
    puts "-----"
    puts
    puts "Total OK:           #{counts[:ok]}"
    puts "Total EXCLUDED:     #{counts[:excluded]}"
    puts "Total ERROR(y2r):   #{counts[:error_y2r]}"
    puts "Total ERROR(ruby):  #{counts[:error_ruby]}"
    puts "Total ERROR(other): #{counts[:error_other]}"

  end

  def compile_stubs
    Dir["#{STUBS_DIR}/*.ycp"].each do |file|
      Cheetah.run @config["ycpc"], "-c", file
    end
  end

  def load_config
    @config = YAML.load_file("#{BASE_DIR}/config.yml")
  end

  def load_module_data
    @modules = {}

    Dir["#{DATA_DIR}/*.yml"].sort.each do |file|
      name = File.basename(file, ".yml")

      @modules[name] = YastModule.new(
        name,
        YAML.load_file(file),
        @modules,
        @config
      )
    end
  end

  def modules_from_names(module_names)
    module_names = @modules.keys if module_names == ["all"]

    @modules.values_at(*module_names)
  end

  def with_modules(modules, activity, print_status)
    max_counter_size = 3 + ((Math.log10(modules.size).to_i + 1) * 2)

    modules.each_index do |i|
      message = sprintf(
        "%-#{max_counter_size}s %s",
        "[#{i + 1}/#{modules.size}]",
        "#{activity} #{modules[i].name}..."
      )

      if print_status
        Messages.start message
      else
        Messages.info message
      end

      begin
        yield modules[i]
      rescue Exception => e
        Messages.finish "ERROR" if print_status
        raise
      end

      Messages.finish "OK" if print_status
    end
  end
end

begin
  CLI.start(ARGV)
rescue Cheetah::ExecutionFailed => e
  puts
  puts e.stderr
rescue Exception => e
  puts
  puts e.message
  puts e.backtrace.join("\n")
end
