#!/usr/bin/env ruby

require "cheetah"
require "thor"
require "yaml"
require "pathname"

BASE_DIR = File.expand_path(File.dirname(__FILE__))

DATA_DIR    = "#{BASE_DIR}/data"
STUBS_DIR   = "#{BASE_DIR}/stubs"
PATCHES_DIR = "#{BASE_DIR}/patches"

ERROR_FILE = "#{BASE_DIR}/error.log"

module Messages
  MAX_MESSAGE_WIDTH = 70

  class << self
    def start(message)
      print message

      @last_message_size = message.size
    end

    def finish(status)
      spaces = if @last_message_size < MAX_MESSAGE_WIDTH
          " " * (MAX_MESSAGE_WIDTH - @last_message_size)
        else
          ""
        end

      puts spaces + status
    end

    def info(message)
      puts message
    end
  end
end

class YastModule
  attr_reader :name,
    :original_dir,
    :converted_dir,
    :structured_dir,
    :excluded,
    :deps,
    :exports

  STRUCTURED_SOURCES_DIR = "work"
  ORIGINAL_SOURCES_DIR = "source"
  CONVERTED_SOURCES_DIR = "target"
  NEW_DIR_STRUCT = {
    :modules   => "src/modules",
    :clients   => "src/clients",
    :include   => "src/include",
    :testsuite => "testsuite",
  }

  def initialize(name, data, modules, config)
    @name    = name
    @data    = data
    @modules = modules
    @config  = config
    @files = {}
    @data["files"].each do |maps|
      next unless maps.is_a? Hash
      prefix = maps["prefix"] || "/"
      ["modules","include","clients","testsuite"].each do |kind|
        next unless maps[kind]
        maps[kind].each do |p|
          @files[File.join(prefix, p)] = { :kind => kind.to_sym, :path => p }
        end
      end
    end if @data["files"].is_a? Array
    
    @original_dir = "#{@config["yast_dir"]}/#{ORIGINAL_SOURCES_DIR}/#@name"
    @structured_dir = "#{@config["yast_dir"]}/#{STRUCTURED_SOURCES_DIR}/#@name"
    @converted_dir ="#{@config["yast_dir"]}/#{CONVERTED_SOURCES_DIR}/#@name"
    @deps = @data["deps"] || []
    @exports = @data["exports"] || ["src"]
    @excluded = @data["excluded"] || []
  end

  def convert
    clean
    clone
    patch
    compile
  end

  def clone
    FileUtils.rm_rf(original_dir)

    Cheetah.run "git", "clone", "git://github.com/yast/yast-#@name.git", original_dir
  end

  def patch
    copy_exists!
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"
    return unless File.exists?(patch_file)

    Dir.chdir structured_dir do
      Cheetah.run "git", "apply", patch_file
    end
  end

  def unpatch
    copy_exists!
    patch_file = "#{PATCHES_DIR}/#{@name}.patch"
    return unless File.exists?(patch_file)

    Dir.chdir structured_dir do
      Cheetah.run "git", "apply", "--reverse", patch_file
    end
  end

  def create_ybcs
    #lazy init it as we need data from other modules
    dep_module_paths = deps.map { |d| @modules[d].exported_module_paths }.flatten
    dep_include_paths = deps.map { |d| @modules[d].exported_include_paths }.flatten

    @module_paths  = [STUBS_DIR] + exported_module_paths + dep_module_paths
    @include_paths = [STUBS_DIR] + exported_include_paths + dep_include_paths
    #for compile we need compiled dependencies
    deps.each{ |m| @modules[m].create_ybcs }
    copy_exists!

    Dir.glob("#{structured_dir}/**/modules/**/*.y{cp,h}", File::FNM_DOTMATCH).each do |file|
      next if File.exists? file.sub(/\.y(cp|h)$/,".ybc")
      Messages.info "Create ybc for #{file}"
      Dir.chdir(File.dirname(file)) do
        create_ybc file, @module_paths, @include_paths
      end
    end
  end

  def compile
    # makes private variables from modules visible for testsuite
    ENV["Y2ALLGLOBAL"] = "1"
    FileUtils.rm_rf(converted_dir)
    counts = {
      :ok          => 0,
      :excluded    => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }
    create_ybcs

    original_prefix = Pathname.new structured_dir
    Dir.glob("#{structured_dir}/**/*", File::FNM_DOTMATCH).each do |file|
      next if File.directory? file
      next if file =~ /\.ybc$/

      relative_path = Pathname.new(file).relative_path_from(original_prefix).to_s
      target_dir = File.join(converted_dir, File.dirname(relative_path))
      FileUtils.mkdir_p target_dir
      if file !~ /\.y(cp|h)$/
        dest = File.join(target_dir, File.basename(file))
        Messages.info "Copy #{file} to #{dest}"
        FileUtils.copy_entry file, dest
      else
        #skip include files as it is often not complete ycp and is part of included files
        next if excluded.include? relative_path
        next if file =~ /\/include\/[^\/]+\.(ycp|yh)$/
        Messages.start "  * #{file}"
        target_file = File.join( target_dir,
          File.basename(file.sub(/\.y(cp|h)$/, ".rb"))
        )
        Dir.chdir File.dirname(file) do
          begin
            create_rb file, target_file, @module_paths, @include_paths
          rescue Cheetah::ExecutionFailed => e
            Messages.finish "ERROR(y2r)"
            log_error(file, e)
            counts[:error_y2r] += 1
            next
          rescue Exception => e
            Messages.finish "ERROR(other)"
            log_error(file, e)
            counts[:error_other] += 1
            next
          end

          begin
            check_rb target_file
          rescue Cheetah::ExecutionFailed => e
            Messages.finish "ERROR(ruby)"
            log_error(file, e)
            counts[:error_ruby] += 1
            next
          rescue Exception => e
            Messages.finish "ERROR(other)"
            log_error(file, e)
            counts[:error_other] += 1
            next
          end

          Messages.finish "OK"
          counts[:ok] += 1
        end
      end
    end

    counts[:excluded] += excluded.size

    counts
  end

  def clean
    FileUtils.rm_rf structured_dir
    FileUtils.rm_rf converted_dir
  end

  def exported_module_paths
    exports.map { |f| File.join(structured_dir, f, "modules") }
  end

  def exported_include_paths
    exports.map { |f| File.join(structured_dir, f, "include") }
  end

  def copy_exists!
    clone unless File.exists? original_dir
    return if File.exists? structured_dir

    prefix = Pathname.new(original_dir)
    Dir.glob("#{original_dir}/**/*", File::FNM_DOTMATCH).each do |f|
      next if File.directory? f
      relative_path = Pathname.new(f).relative_path_from(prefix).to_s
      target_dir = if @files[relative_path]
          File.join(structured_dir, 
            NEW_DIR_STRUCT[@files[relative_path][:kind]],
            File.dirname(@files[relative_path][:path])
          )
        else
          File.join(structured_dir, File.dirname(relative_path))
        end
      FileUtils.mkdir_p target_dir
      FileUtils.copy_entry f, File.join(target_dir, File.basename(f))
    end
    do_workdir_modify
  end

  private
  def do_workdir_modify
    config = @data["work_modify"]
    return unless config

    config["mkdir"].each do |dir|
      puts "mkdir #{dir}"
      FileUtils.mkdir_p File.join(structured_dir, dir)
    end if config["mkdir"]

    config["mv"].each do |mv|
      Dir.glob("#{structured_dir}/#{mv["source"]}", File::FNM_DOTMATCH) do |f|
        puts "mv #{f} to #{mv["target"]}"
        FileUtils.mv f, File.join(structured_dir, mv["target"])
      end
    end if config["mv"]
  end

  def create_ybc(file, module_paths, include_paths)
    cmd = [@config["ycpc"]]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << "-c" << file

    Cheetah.run cmd
  end

  def create_rb(file, target_file, module_paths, include_paths)
    cmd = [@config["y2r"]]
    cmd << "--ycpc" << @config["ycpc"]
    module_paths.each do |module_path|
      cmd << "--module-path" << module_path
    end
    include_paths.each do |include_path|
      cmd << "--include-path" << include_path
    end
    cmd << file
    cmd << target_file

    Cheetah.run cmd
  end

  def check_rb(file)
    Cheetah.run "ruby", "-c", file
  end

  def log_error(file, e)
    File.open(ERROR_FILE, "a") do |f|
      f.puts file
      f.puts "-" * file.size
      f.puts
      if e.is_a? Cheetah::ExecutionFailed
        f.puts e.stderr
      else
        f.puts e.message
        e.backtrace.each {|l| f.puts l }
      end
      f.puts
    end
  end

end

class CLI < Thor
  def initialize(*args)
    super *args

    load_config
    load_module_data
  end

  desc "clone <module>...", "Clone module(s)"
  def clone(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Cloning", true do |mod|
      mod.clone
    end
  end

  desc "convert <module>...", "Convert module(s) to target dir"
  def convert(*module_names)
    compile_stubs

    FileUtils.rm_rf(ERROR_FILE)

    counts = {
      :ok          => 0,
      :excluded    => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }


    modules = modules_from_names(module_names)
    with_modules modules, "Checking files in", true do |mod|
      module_counts = mod.convert
      counts.keys.each { |k| counts[k] += module_counts[k] }
    end

    puts
    puts "-----"
    puts
    puts "Total OK:           #{counts[:ok]}"
    puts "Total EXCLUDED:     #{counts[:excluded]}"
    puts "Total ERROR(y2r):   #{counts[:error_y2r]}"
    puts "Total ERROR(ruby):  #{counts[:error_ruby]}"
    puts "Total ERROR(other): #{counts[:error_other]}"
  end

  desc "create_workdir <module>...", "Check file lists for module(s)"
  def create_workdir(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Copying files in", true do |mod|
      mod.copy_exists!
    end
  end

  desc "patch <module>...", "Patch module(s)"
  def patch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Patching", true do |mod|
      mod.patch
    end
  end

  desc "unpatch <module>...", "Unpatch module(s)"
  def unpatch(*module_names)
    modules = modules_from_names(module_names)
    with_modules modules, "Unpatching", true do |mod|
      mod.unpatch
    end
  end

  desc "compile <module>...", "Compile module(s)"
  def compile(*module_names)
    compile_stubs

    FileUtils.rm_rf(ERROR_FILE)

    counts = {
      :ok          => 0,
      :excluded    => 0,
      :error_y2r   => 0,
      :error_ruby  => 0,
      :error_other => 0
    }

    modules = modules_from_names(module_names)
    with_modules modules, "Compiling", false do |mod|
      module_counts = mod.compile
      counts.keys.each { |k| counts[k] += module_counts[k] }
    end

    puts
    puts "-----"
    puts
    puts "Total OK:           #{counts[:ok]}"
    puts "Total EXCLUDED:     #{counts[:excluded]}"
    puts "Total ERROR(y2r):   #{counts[:error_y2r]}"
    puts "Total ERROR(ruby):  #{counts[:error_ruby]}"
    puts "Total ERROR(other): #{counts[:error_other]}"
  end

  desc "clean <module>...", "Clean up compilation results for module(s)"
  def clean(*module_names)
    clean_stubs

    FileUtils.rm_rf(ERROR_FILE)

    modules = modules_from_names(module_names)
    with_modules modules, "Cleaning up", true do |mod|
      mod.clean
    end
  end

  private

  def compile_stubs
    Dir["#{STUBS_DIR}/*.ycp"].each do |file|
      Cheetah.run @config["ycpc"], "-c", file
    end
  end

  def clean_stubs
    Dir["#{STUBS_DIR}/*.ybc"].each do |file|
      FileUtils.rm(file)
    end
  end

  def load_config
    @config = YAML.load_file("#{BASE_DIR}/config.yml")
  end

  def load_module_data
    @modules = {}

    Dir["#{DATA_DIR}/*.yml"].sort.each do |file|
      name = File.basename(file, ".yml")

      @modules[name] = YastModule.new(
        name,
        YAML.load_file(file),
        @modules,
        @config
      )
    end
  end

  def modules_from_names(module_names)
    module_names = @modules.keys if module_names == ["all"]

    @modules.values_at(*module_names)
  end

  def with_modules(modules, activity, print_status)
    max_counter_size = 3 + ((Math.log10(modules.size).to_i + 1) * 2)

    modules.each_index do |i|
      message = sprintf(
        "%-#{max_counter_size}s %s",
        "[#{i + 1}/#{modules.size}]",
        "#{activity} #{modules[i].name}..."
      )

      if print_status
        Messages.start message
      else
        Messages.info message
      end

      begin
        yield modules[i]
      rescue Exception => e
        Messages.finish "ERROR" if print_status
        raise
      end

      Messages.finish "OK" if print_status
    end
  end
end

begin
  CLI.start(ARGV)
rescue Cheetah::ExecutionFailed => e
  puts "Command Failed"
  puts e.stderr
rescue Exception => e
  puts
  puts e.message
  puts e.backtrace.inspect
end
