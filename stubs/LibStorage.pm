# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package LibStorage;
use base qw(Exporter);
use base qw(DynaLoader);
package LibStoragec;
bootstrap LibStorage;
package LibStorage;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package LibStorage;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package LibStorage;

*initDefaultLogger = *LibStoragec::initDefaultLogger;
*setLogDoCallback = *LibStoragec::setLogDoCallback;
*getLogDoCallback = *LibStoragec::getLogDoCallback;
*setLogQueryCallback = *LibStoragec::setLogQueryCallback;
*getLogQueryCallback = *LibStoragec::getLogQueryCallback;
*createStorageInterface = *LibStoragec::createStorageInterface;
*createStorageInterfacePid = *LibStoragec::createStorageInterfacePid;
*destroyStorageInterface = *LibStoragec::destroyStorageInterface;
*numSuffixes = *LibStoragec::numSuffixes;
*getSuffix = *LibStoragec::getSuffix;
*byteToHumanString = *LibStoragec::byteToHumanString;
*humanStringToByte = *LibStoragec::humanStringToByte;
*saveDeviceGraph = *LibStoragec::saveDeviceGraph;
*saveMountGraph = *LibStoragec::saveMountGraph;

############# Class : LibStorage::FsCapabilities ##############

package LibStorage::FsCapabilities;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_FsCapabilities(@_);
    bless $self, $pkg if defined($self);
}

*swig_isExtendable_get = *LibStoragec::FsCapabilities_isExtendable_get;
*swig_isExtendable_set = *LibStoragec::FsCapabilities_isExtendable_set;
*swig_isExtendableWhileMounted_get = *LibStoragec::FsCapabilities_isExtendableWhileMounted_get;
*swig_isExtendableWhileMounted_set = *LibStoragec::FsCapabilities_isExtendableWhileMounted_set;
*swig_isReduceable_get = *LibStoragec::FsCapabilities_isReduceable_get;
*swig_isReduceable_set = *LibStoragec::FsCapabilities_isReduceable_set;
*swig_isReduceableWhileMounted_get = *LibStoragec::FsCapabilities_isReduceableWhileMounted_get;
*swig_isReduceableWhileMounted_set = *LibStoragec::FsCapabilities_isReduceableWhileMounted_set;
*swig_supportsUuid_get = *LibStoragec::FsCapabilities_supportsUuid_get;
*swig_supportsUuid_set = *LibStoragec::FsCapabilities_supportsUuid_set;
*swig_supportsLabel_get = *LibStoragec::FsCapabilities_supportsLabel_get;
*swig_supportsLabel_set = *LibStoragec::FsCapabilities_supportsLabel_set;
*swig_labelWhileMounted_get = *LibStoragec::FsCapabilities_labelWhileMounted_get;
*swig_labelWhileMounted_set = *LibStoragec::FsCapabilities_labelWhileMounted_set;
*swig_labelLength_get = *LibStoragec::FsCapabilities_labelLength_get;
*swig_labelLength_set = *LibStoragec::FsCapabilities_labelLength_set;
*swig_minimalFsSizeK_get = *LibStoragec::FsCapabilities_minimalFsSizeK_get;
*swig_minimalFsSizeK_set = *LibStoragec::FsCapabilities_minimalFsSizeK_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_FsCapabilities($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DlabelCapabilities ##############

package LibStorage::DlabelCapabilities;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DlabelCapabilities(@_);
    bless $self, $pkg if defined($self);
}

*swig_maxPrimary_get = *LibStoragec::DlabelCapabilities_maxPrimary_get;
*swig_maxPrimary_set = *LibStoragec::DlabelCapabilities_maxPrimary_set;
*swig_extendedPossible_get = *LibStoragec::DlabelCapabilities_extendedPossible_get;
*swig_extendedPossible_set = *LibStoragec::DlabelCapabilities_extendedPossible_set;
*swig_maxLogical_get = *LibStoragec::DlabelCapabilities_maxLogical_get;
*swig_maxLogical_set = *LibStoragec::DlabelCapabilities_maxLogical_set;
*swig_maxSectors_get = *LibStoragec::DlabelCapabilities_maxSectors_get;
*swig_maxSectors_set = *LibStoragec::DlabelCapabilities_maxSectors_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DlabelCapabilities($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::UsedByInfo ##############

package LibStorage::UsedByInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_UsedByInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_type_get = *LibStoragec::UsedByInfo_type_get;
*swig_type_set = *LibStoragec::UsedByInfo_type_set;
*swig_device_get = *LibStoragec::UsedByInfo_device_get;
*swig_device_set = *LibStoragec::UsedByInfo_device_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_UsedByInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::SubvolInfo ##############

package LibStorage::SubvolInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_SubvolInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_path_get = *LibStoragec::SubvolInfo_path_get;
*swig_path_set = *LibStoragec::SubvolInfo_path_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_SubvolInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::ResizeInfo ##############

package LibStorage::ResizeInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_ResizeInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_df_freeK_get = *LibStoragec::ResizeInfo_df_freeK_get;
*swig_df_freeK_set = *LibStoragec::ResizeInfo_df_freeK_set;
*swig_resize_freeK_get = *LibStoragec::ResizeInfo_resize_freeK_get;
*swig_resize_freeK_set = *LibStoragec::ResizeInfo_resize_freeK_set;
*swig_usedK_get = *LibStoragec::ResizeInfo_usedK_get;
*swig_usedK_set = *LibStoragec::ResizeInfo_usedK_set;
*swig_resize_ok_get = *LibStoragec::ResizeInfo_resize_ok_get;
*swig_resize_ok_set = *LibStoragec::ResizeInfo_resize_ok_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_ResizeInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::ContentInfo ##############

package LibStorage::ContentInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_ContentInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_windows_get = *LibStoragec::ContentInfo_windows_get;
*swig_windows_set = *LibStoragec::ContentInfo_windows_set;
*swig_efi_get = *LibStoragec::ContentInfo_efi_get;
*swig_efi_set = *LibStoragec::ContentInfo_efi_set;
*swig_homes_get = *LibStoragec::ContentInfo_homes_get;
*swig_homes_set = *LibStoragec::ContentInfo_homes_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_ContentInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::ContainerInfo ##############

package LibStorage::ContainerInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_ContainerInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_type_get = *LibStoragec::ContainerInfo_type_get;
*swig_type_set = *LibStoragec::ContainerInfo_type_set;
*swig_device_get = *LibStoragec::ContainerInfo_device_get;
*swig_device_set = *LibStoragec::ContainerInfo_device_set;
*swig_name_get = *LibStoragec::ContainerInfo_name_get;
*swig_name_set = *LibStoragec::ContainerInfo_name_set;
*swig_udevPath_get = *LibStoragec::ContainerInfo_udevPath_get;
*swig_udevPath_set = *LibStoragec::ContainerInfo_udevPath_set;
*swig_udevId_get = *LibStoragec::ContainerInfo_udevId_get;
*swig_udevId_set = *LibStoragec::ContainerInfo_udevId_set;
*swig_usedBy_get = *LibStoragec::ContainerInfo_usedBy_get;
*swig_usedBy_set = *LibStoragec::ContainerInfo_usedBy_set;
*swig_usedByType_get = *LibStoragec::ContainerInfo_usedByType_get;
*swig_usedByType_set = *LibStoragec::ContainerInfo_usedByType_set;
*swig_usedByDevice_get = *LibStoragec::ContainerInfo_usedByDevice_get;
*swig_usedByDevice_set = *LibStoragec::ContainerInfo_usedByDevice_set;
*swig_readonly_get = *LibStoragec::ContainerInfo_readonly_get;
*swig_readonly_set = *LibStoragec::ContainerInfo_readonly_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_ContainerInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DiskInfo ##############

package LibStorage::DiskInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DiskInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_sizeK_get = *LibStoragec::DiskInfo_sizeK_get;
*swig_sizeK_set = *LibStoragec::DiskInfo_sizeK_set;
*swig_cylSize_get = *LibStoragec::DiskInfo_cylSize_get;
*swig_cylSize_set = *LibStoragec::DiskInfo_cylSize_set;
*swig_cyl_get = *LibStoragec::DiskInfo_cyl_get;
*swig_cyl_set = *LibStoragec::DiskInfo_cyl_set;
*swig_heads_get = *LibStoragec::DiskInfo_heads_get;
*swig_heads_set = *LibStoragec::DiskInfo_heads_set;
*swig_sectors_get = *LibStoragec::DiskInfo_sectors_get;
*swig_sectors_set = *LibStoragec::DiskInfo_sectors_set;
*swig_sectorSize_get = *LibStoragec::DiskInfo_sectorSize_get;
*swig_sectorSize_set = *LibStoragec::DiskInfo_sectorSize_set;
*swig_disklabel_get = *LibStoragec::DiskInfo_disklabel_get;
*swig_disklabel_set = *LibStoragec::DiskInfo_disklabel_set;
*swig_orig_disklabel_get = *LibStoragec::DiskInfo_orig_disklabel_get;
*swig_orig_disklabel_set = *LibStoragec::DiskInfo_orig_disklabel_set;
*swig_maxPrimary_get = *LibStoragec::DiskInfo_maxPrimary_get;
*swig_maxPrimary_set = *LibStoragec::DiskInfo_maxPrimary_set;
*swig_extendedPossible_get = *LibStoragec::DiskInfo_extendedPossible_get;
*swig_extendedPossible_set = *LibStoragec::DiskInfo_extendedPossible_set;
*swig_maxLogical_get = *LibStoragec::DiskInfo_maxLogical_get;
*swig_maxLogical_set = *LibStoragec::DiskInfo_maxLogical_set;
*swig_initDisk_get = *LibStoragec::DiskInfo_initDisk_get;
*swig_initDisk_set = *LibStoragec::DiskInfo_initDisk_set;
*swig_transport_get = *LibStoragec::DiskInfo_transport_get;
*swig_transport_set = *LibStoragec::DiskInfo_transport_set;
*swig_has_fake_partition_get = *LibStoragec::DiskInfo_has_fake_partition_get;
*swig_has_fake_partition_set = *LibStoragec::DiskInfo_has_fake_partition_set;
*swig_iscsi_get = *LibStoragec::DiskInfo_iscsi_get;
*swig_iscsi_set = *LibStoragec::DiskInfo_iscsi_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DiskInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::LvmVgInfo ##############

package LibStorage::LvmVgInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_LvmVgInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_sizeK_get = *LibStoragec::LvmVgInfo_sizeK_get;
*swig_sizeK_set = *LibStoragec::LvmVgInfo_sizeK_set;
*swig_peSizeK_get = *LibStoragec::LvmVgInfo_peSizeK_get;
*swig_peSizeK_set = *LibStoragec::LvmVgInfo_peSizeK_set;
*swig_peCount_get = *LibStoragec::LvmVgInfo_peCount_get;
*swig_peCount_set = *LibStoragec::LvmVgInfo_peCount_set;
*swig_peFree_get = *LibStoragec::LvmVgInfo_peFree_get;
*swig_peFree_set = *LibStoragec::LvmVgInfo_peFree_set;
*swig_uuid_get = *LibStoragec::LvmVgInfo_uuid_get;
*swig_uuid_set = *LibStoragec::LvmVgInfo_uuid_set;
*swig_lvm2_get = *LibStoragec::LvmVgInfo_lvm2_get;
*swig_lvm2_set = *LibStoragec::LvmVgInfo_lvm2_set;
*swig_create_get = *LibStoragec::LvmVgInfo_create_get;
*swig_create_set = *LibStoragec::LvmVgInfo_create_set;
*swig_devices_get = *LibStoragec::LvmVgInfo_devices_get;
*swig_devices_set = *LibStoragec::LvmVgInfo_devices_set;
*swig_devices_add_get = *LibStoragec::LvmVgInfo_devices_add_get;
*swig_devices_add_set = *LibStoragec::LvmVgInfo_devices_add_set;
*swig_devices_rem_get = *LibStoragec::LvmVgInfo_devices_rem_get;
*swig_devices_rem_set = *LibStoragec::LvmVgInfo_devices_rem_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_LvmVgInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmPartCoInfo ##############

package LibStorage::DmPartCoInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmPartCoInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_d_get = *LibStoragec::DmPartCoInfo_d_get;
*swig_d_set = *LibStoragec::DmPartCoInfo_d_set;
*swig_devices_get = *LibStoragec::DmPartCoInfo_devices_get;
*swig_devices_set = *LibStoragec::DmPartCoInfo_devices_set;
*swig_minor_get = *LibStoragec::DmPartCoInfo_minor_get;
*swig_minor_set = *LibStoragec::DmPartCoInfo_minor_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmPartCoInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmraidCoInfo ##############

package LibStorage::DmraidCoInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmraidCoInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_p_get = *LibStoragec::DmraidCoInfo_p_get;
*swig_p_set = *LibStoragec::DmraidCoInfo_p_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmraidCoInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmmultipathCoInfo ##############

package LibStorage::DmmultipathCoInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmmultipathCoInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_p_get = *LibStoragec::DmmultipathCoInfo_p_get;
*swig_p_set = *LibStoragec::DmmultipathCoInfo_p_set;
*swig_vendor_get = *LibStoragec::DmmultipathCoInfo_vendor_get;
*swig_vendor_set = *LibStoragec::DmmultipathCoInfo_vendor_set;
*swig_model_get = *LibStoragec::DmmultipathCoInfo_model_get;
*swig_model_set = *LibStoragec::DmmultipathCoInfo_model_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmmultipathCoInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::VolumeInfo ##############

package LibStorage::VolumeInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_VolumeInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_sizeK_get = *LibStoragec::VolumeInfo_sizeK_get;
*swig_sizeK_set = *LibStoragec::VolumeInfo_sizeK_set;
*swig_major_get = *LibStoragec::VolumeInfo_major_get;
*swig_major_set = *LibStoragec::VolumeInfo_major_set;
*swig_minor_get = *LibStoragec::VolumeInfo_minor_get;
*swig_minor_set = *LibStoragec::VolumeInfo_minor_set;
*swig_name_get = *LibStoragec::VolumeInfo_name_get;
*swig_name_set = *LibStoragec::VolumeInfo_name_set;
*swig_device_get = *LibStoragec::VolumeInfo_device_get;
*swig_device_set = *LibStoragec::VolumeInfo_device_set;
*swig_mount_get = *LibStoragec::VolumeInfo_mount_get;
*swig_mount_set = *LibStoragec::VolumeInfo_mount_set;
*swig_crypt_device_get = *LibStoragec::VolumeInfo_crypt_device_get;
*swig_crypt_device_set = *LibStoragec::VolumeInfo_crypt_device_set;
*swig_mount_by_get = *LibStoragec::VolumeInfo_mount_by_get;
*swig_mount_by_set = *LibStoragec::VolumeInfo_mount_by_set;
*swig_udevPath_get = *LibStoragec::VolumeInfo_udevPath_get;
*swig_udevPath_set = *LibStoragec::VolumeInfo_udevPath_set;
*swig_udevId_get = *LibStoragec::VolumeInfo_udevId_get;
*swig_udevId_set = *LibStoragec::VolumeInfo_udevId_set;
*swig_usedBy_get = *LibStoragec::VolumeInfo_usedBy_get;
*swig_usedBy_set = *LibStoragec::VolumeInfo_usedBy_set;
*swig_usedByType_get = *LibStoragec::VolumeInfo_usedByType_get;
*swig_usedByType_set = *LibStoragec::VolumeInfo_usedByType_set;
*swig_usedByDevice_get = *LibStoragec::VolumeInfo_usedByDevice_get;
*swig_usedByDevice_set = *LibStoragec::VolumeInfo_usedByDevice_set;
*swig_ignore_fstab_get = *LibStoragec::VolumeInfo_ignore_fstab_get;
*swig_ignore_fstab_set = *LibStoragec::VolumeInfo_ignore_fstab_set;
*swig_fstab_options_get = *LibStoragec::VolumeInfo_fstab_options_get;
*swig_fstab_options_set = *LibStoragec::VolumeInfo_fstab_options_set;
*swig_uuid_get = *LibStoragec::VolumeInfo_uuid_get;
*swig_uuid_set = *LibStoragec::VolumeInfo_uuid_set;
*swig_label_get = *LibStoragec::VolumeInfo_label_get;
*swig_label_set = *LibStoragec::VolumeInfo_label_set;
*swig_mkfs_options_get = *LibStoragec::VolumeInfo_mkfs_options_get;
*swig_mkfs_options_set = *LibStoragec::VolumeInfo_mkfs_options_set;
*swig_tunefs_options_get = *LibStoragec::VolumeInfo_tunefs_options_get;
*swig_tunefs_options_set = *LibStoragec::VolumeInfo_tunefs_options_set;
*swig_loop_get = *LibStoragec::VolumeInfo_loop_get;
*swig_loop_set = *LibStoragec::VolumeInfo_loop_set;
*swig_dtxt_get = *LibStoragec::VolumeInfo_dtxt_get;
*swig_dtxt_set = *LibStoragec::VolumeInfo_dtxt_set;
*swig_encryption_get = *LibStoragec::VolumeInfo_encryption_get;
*swig_encryption_set = *LibStoragec::VolumeInfo_encryption_set;
*swig_crypt_pwd_get = *LibStoragec::VolumeInfo_crypt_pwd_get;
*swig_crypt_pwd_set = *LibStoragec::VolumeInfo_crypt_pwd_set;
*swig_fs_get = *LibStoragec::VolumeInfo_fs_get;
*swig_fs_set = *LibStoragec::VolumeInfo_fs_set;
*swig_detected_fs_get = *LibStoragec::VolumeInfo_detected_fs_get;
*swig_detected_fs_set = *LibStoragec::VolumeInfo_detected_fs_set;
*swig_format_get = *LibStoragec::VolumeInfo_format_get;
*swig_format_set = *LibStoragec::VolumeInfo_format_set;
*swig_create_get = *LibStoragec::VolumeInfo_create_get;
*swig_create_set = *LibStoragec::VolumeInfo_create_set;
*swig_is_mounted_get = *LibStoragec::VolumeInfo_is_mounted_get;
*swig_is_mounted_set = *LibStoragec::VolumeInfo_is_mounted_set;
*swig_resize_get = *LibStoragec::VolumeInfo_resize_get;
*swig_resize_set = *LibStoragec::VolumeInfo_resize_set;
*swig_ignore_fs_get = *LibStoragec::VolumeInfo_ignore_fs_get;
*swig_ignore_fs_set = *LibStoragec::VolumeInfo_ignore_fs_set;
*swig_origSizeK_get = *LibStoragec::VolumeInfo_origSizeK_get;
*swig_origSizeK_set = *LibStoragec::VolumeInfo_origSizeK_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_VolumeInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::PartitionAddInfo ##############

package LibStorage::PartitionAddInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_PartitionAddInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_nr_get = *LibStoragec::PartitionAddInfo_nr_get;
*swig_nr_set = *LibStoragec::PartitionAddInfo_nr_set;
*swig_cylStart_get = *LibStoragec::PartitionAddInfo_cylStart_get;
*swig_cylStart_set = *LibStoragec::PartitionAddInfo_cylStart_set;
*swig_cylSize_get = *LibStoragec::PartitionAddInfo_cylSize_get;
*swig_cylSize_set = *LibStoragec::PartitionAddInfo_cylSize_set;
*swig_partitionType_get = *LibStoragec::PartitionAddInfo_partitionType_get;
*swig_partitionType_set = *LibStoragec::PartitionAddInfo_partitionType_set;
*swig_id_get = *LibStoragec::PartitionAddInfo_id_get;
*swig_id_set = *LibStoragec::PartitionAddInfo_id_set;
*swig_boot_get = *LibStoragec::PartitionAddInfo_boot_get;
*swig_boot_set = *LibStoragec::PartitionAddInfo_boot_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_PartitionAddInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::PartitionInfo ##############

package LibStorage::PartitionInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_PartitionInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::PartitionInfo_v_get;
*swig_v_set = *LibStoragec::PartitionInfo_v_set;
*swig_nr_get = *LibStoragec::PartitionInfo_nr_get;
*swig_nr_set = *LibStoragec::PartitionInfo_nr_set;
*swig_cylStart_get = *LibStoragec::PartitionInfo_cylStart_get;
*swig_cylStart_set = *LibStoragec::PartitionInfo_cylStart_set;
*swig_cylSize_get = *LibStoragec::PartitionInfo_cylSize_get;
*swig_cylSize_set = *LibStoragec::PartitionInfo_cylSize_set;
*swig_partitionType_get = *LibStoragec::PartitionInfo_partitionType_get;
*swig_partitionType_set = *LibStoragec::PartitionInfo_partitionType_set;
*swig_id_get = *LibStoragec::PartitionInfo_id_get;
*swig_id_set = *LibStoragec::PartitionInfo_id_set;
*swig_boot_get = *LibStoragec::PartitionInfo_boot_get;
*swig_boot_set = *LibStoragec::PartitionInfo_boot_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_PartitionInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::LvmLvInfo ##############

package LibStorage::LvmLvInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_LvmLvInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::LvmLvInfo_v_get;
*swig_v_set = *LibStoragec::LvmLvInfo_v_set;
*swig_stripes_get = *LibStoragec::LvmLvInfo_stripes_get;
*swig_stripes_set = *LibStoragec::LvmLvInfo_stripes_set;
*swig_stripeSizeK_get = *LibStoragec::LvmLvInfo_stripeSizeK_get;
*swig_stripeSizeK_set = *LibStoragec::LvmLvInfo_stripeSizeK_set;
*swig_uuid_get = *LibStoragec::LvmLvInfo_uuid_get;
*swig_uuid_set = *LibStoragec::LvmLvInfo_uuid_set;
*swig_status_get = *LibStoragec::LvmLvInfo_status_get;
*swig_status_set = *LibStoragec::LvmLvInfo_status_set;
*swig_allocation_get = *LibStoragec::LvmLvInfo_allocation_get;
*swig_allocation_set = *LibStoragec::LvmLvInfo_allocation_set;
*swig_dm_table_get = *LibStoragec::LvmLvInfo_dm_table_get;
*swig_dm_table_set = *LibStoragec::LvmLvInfo_dm_table_set;
*swig_dm_target_get = *LibStoragec::LvmLvInfo_dm_target_get;
*swig_dm_target_set = *LibStoragec::LvmLvInfo_dm_target_set;
*swig_origin_get = *LibStoragec::LvmLvInfo_origin_get;
*swig_origin_set = *LibStoragec::LvmLvInfo_origin_set;
*swig_used_pool_get = *LibStoragec::LvmLvInfo_used_pool_get;
*swig_used_pool_set = *LibStoragec::LvmLvInfo_used_pool_set;
*swig_pool_get = *LibStoragec::LvmLvInfo_pool_get;
*swig_pool_set = *LibStoragec::LvmLvInfo_pool_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_LvmLvInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::LvmLvSnapshotStateInfo ##############

package LibStorage::LvmLvSnapshotStateInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_LvmLvSnapshotStateInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_active_get = *LibStoragec::LvmLvSnapshotStateInfo_active_get;
*swig_active_set = *LibStoragec::LvmLvSnapshotStateInfo_active_set;
*swig_allocated_get = *LibStoragec::LvmLvSnapshotStateInfo_allocated_get;
*swig_allocated_set = *LibStoragec::LvmLvSnapshotStateInfo_allocated_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_LvmLvSnapshotStateInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::MdInfo ##############

package LibStorage::MdInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_MdInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::MdInfo_v_get;
*swig_v_set = *LibStoragec::MdInfo_v_set;
*swig_nr_get = *LibStoragec::MdInfo_nr_get;
*swig_nr_set = *LibStoragec::MdInfo_nr_set;
*swig_type_get = *LibStoragec::MdInfo_type_get;
*swig_type_set = *LibStoragec::MdInfo_type_set;
*swig_parity_get = *LibStoragec::MdInfo_parity_get;
*swig_parity_set = *LibStoragec::MdInfo_parity_set;
*swig_uuid_get = *LibStoragec::MdInfo_uuid_get;
*swig_uuid_set = *LibStoragec::MdInfo_uuid_set;
*swig_sb_ver_get = *LibStoragec::MdInfo_sb_ver_get;
*swig_sb_ver_set = *LibStoragec::MdInfo_sb_ver_set;
*swig_chunkSizeK_get = *LibStoragec::MdInfo_chunkSizeK_get;
*swig_chunkSizeK_set = *LibStoragec::MdInfo_chunkSizeK_set;
*swig_devices_get = *LibStoragec::MdInfo_devices_get;
*swig_devices_set = *LibStoragec::MdInfo_devices_set;
*swig_spares_get = *LibStoragec::MdInfo_spares_get;
*swig_spares_set = *LibStoragec::MdInfo_spares_set;
*swig_inactive_get = *LibStoragec::MdInfo_inactive_get;
*swig_inactive_set = *LibStoragec::MdInfo_inactive_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_MdInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::MdStateInfo ##############

package LibStorage::MdStateInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_MdStateInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_state_get = *LibStoragec::MdStateInfo_state_get;
*swig_state_set = *LibStoragec::MdStateInfo_state_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_MdStateInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::MdPartCoInfo ##############

package LibStorage::MdPartCoInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_MdPartCoInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_d_get = *LibStoragec::MdPartCoInfo_d_get;
*swig_d_set = *LibStoragec::MdPartCoInfo_d_set;
*swig_type_get = *LibStoragec::MdPartCoInfo_type_get;
*swig_type_set = *LibStoragec::MdPartCoInfo_type_set;
*swig_nr_get = *LibStoragec::MdPartCoInfo_nr_get;
*swig_nr_set = *LibStoragec::MdPartCoInfo_nr_set;
*swig_parity_get = *LibStoragec::MdPartCoInfo_parity_get;
*swig_parity_set = *LibStoragec::MdPartCoInfo_parity_set;
*swig_uuid_get = *LibStoragec::MdPartCoInfo_uuid_get;
*swig_uuid_set = *LibStoragec::MdPartCoInfo_uuid_set;
*swig_sb_ver_get = *LibStoragec::MdPartCoInfo_sb_ver_get;
*swig_sb_ver_set = *LibStoragec::MdPartCoInfo_sb_ver_set;
*swig_chunkSizeK_get = *LibStoragec::MdPartCoInfo_chunkSizeK_get;
*swig_chunkSizeK_set = *LibStoragec::MdPartCoInfo_chunkSizeK_set;
*swig_devices_get = *LibStoragec::MdPartCoInfo_devices_get;
*swig_devices_set = *LibStoragec::MdPartCoInfo_devices_set;
*swig_spares_get = *LibStoragec::MdPartCoInfo_spares_get;
*swig_spares_set = *LibStoragec::MdPartCoInfo_spares_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_MdPartCoInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::MdPartCoStateInfo ##############

package LibStorage::MdPartCoStateInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_MdPartCoStateInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_state_get = *LibStoragec::MdPartCoStateInfo_state_get;
*swig_state_set = *LibStoragec::MdPartCoStateInfo_state_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_MdPartCoStateInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::MdPartInfo ##############

package LibStorage::MdPartInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_MdPartInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::MdPartInfo_v_get;
*swig_v_set = *LibStoragec::MdPartInfo_v_set;
*swig_p_get = *LibStoragec::MdPartInfo_p_get;
*swig_p_set = *LibStoragec::MdPartInfo_p_set;
*swig_part_get = *LibStoragec::MdPartInfo_part_get;
*swig_part_set = *LibStoragec::MdPartInfo_part_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_MdPartInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::NfsInfo ##############

package LibStorage::NfsInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_NfsInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::NfsInfo_v_get;
*swig_v_set = *LibStoragec::NfsInfo_v_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_NfsInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::LoopInfo ##############

package LibStorage::LoopInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_LoopInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::LoopInfo_v_get;
*swig_v_set = *LibStoragec::LoopInfo_v_set;
*swig_reuseFile_get = *LibStoragec::LoopInfo_reuseFile_get;
*swig_reuseFile_set = *LibStoragec::LoopInfo_reuseFile_set;
*swig_nr_get = *LibStoragec::LoopInfo_nr_get;
*swig_nr_set = *LibStoragec::LoopInfo_nr_set;
*swig_file_get = *LibStoragec::LoopInfo_file_get;
*swig_file_set = *LibStoragec::LoopInfo_file_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_LoopInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::BtrfsInfo ##############

package LibStorage::BtrfsInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_BtrfsInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::BtrfsInfo_v_get;
*swig_v_set = *LibStoragec::BtrfsInfo_v_set;
*swig_devices_get = *LibStoragec::BtrfsInfo_devices_get;
*swig_devices_set = *LibStoragec::BtrfsInfo_devices_set;
*swig_devices_add_get = *LibStoragec::BtrfsInfo_devices_add_get;
*swig_devices_add_set = *LibStoragec::BtrfsInfo_devices_add_set;
*swig_devices_rem_get = *LibStoragec::BtrfsInfo_devices_rem_get;
*swig_devices_rem_set = *LibStoragec::BtrfsInfo_devices_rem_set;
*swig_subvol_get = *LibStoragec::BtrfsInfo_subvol_get;
*swig_subvol_set = *LibStoragec::BtrfsInfo_subvol_set;
*swig_subvol_add_get = *LibStoragec::BtrfsInfo_subvol_add_get;
*swig_subvol_add_set = *LibStoragec::BtrfsInfo_subvol_add_set;
*swig_subvol_rem_get = *LibStoragec::BtrfsInfo_subvol_rem_get;
*swig_subvol_rem_set = *LibStoragec::BtrfsInfo_subvol_rem_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_BtrfsInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::TmpfsInfo ##############

package LibStorage::TmpfsInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_TmpfsInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::TmpfsInfo_v_get;
*swig_v_set = *LibStoragec::TmpfsInfo_v_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_TmpfsInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmInfo ##############

package LibStorage::DmInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::DmInfo_v_get;
*swig_v_set = *LibStoragec::DmInfo_v_set;
*swig_nr_get = *LibStoragec::DmInfo_nr_get;
*swig_nr_set = *LibStoragec::DmInfo_nr_set;
*swig_table_get = *LibStoragec::DmInfo_table_get;
*swig_table_set = *LibStoragec::DmInfo_table_set;
*swig_target_get = *LibStoragec::DmInfo_target_get;
*swig_target_set = *LibStoragec::DmInfo_target_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmPartInfo ##############

package LibStorage::DmPartInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmPartInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_v_get = *LibStoragec::DmPartInfo_v_get;
*swig_v_set = *LibStoragec::DmPartInfo_v_set;
*swig_p_get = *LibStoragec::DmPartInfo_p_get;
*swig_p_set = *LibStoragec::DmPartInfo_p_set;
*swig_part_get = *LibStoragec::DmPartInfo_part_get;
*swig_part_set = *LibStoragec::DmPartInfo_part_set;
*swig_table_get = *LibStoragec::DmPartInfo_table_get;
*swig_table_set = *LibStoragec::DmPartInfo_table_set;
*swig_target_get = *LibStoragec::DmPartInfo_target_get;
*swig_target_set = *LibStoragec::DmPartInfo_target_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmPartInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmraidInfo ##############

package LibStorage::DmraidInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmraidInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_p_get = *LibStoragec::DmraidInfo_p_get;
*swig_p_set = *LibStoragec::DmraidInfo_p_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmraidInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::DmmultipathInfo ##############

package LibStorage::DmmultipathInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_DmmultipathInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_p_get = *LibStoragec::DmmultipathInfo_p_get;
*swig_p_set = *LibStoragec::DmmultipathInfo_p_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_DmmultipathInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::ContVolInfo ##############

package LibStorage::ContVolInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_ContVolInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_ctype_get = *LibStoragec::ContVolInfo_ctype_get;
*swig_ctype_set = *LibStoragec::ContVolInfo_ctype_set;
*swig_cname_get = *LibStoragec::ContVolInfo_cname_get;
*swig_cname_set = *LibStoragec::ContVolInfo_cname_set;
*swig_cdevice_get = *LibStoragec::ContVolInfo_cdevice_get;
*swig_cdevice_set = *LibStoragec::ContVolInfo_cdevice_set;
*swig_vname_get = *LibStoragec::ContVolInfo_vname_get;
*swig_vname_set = *LibStoragec::ContVolInfo_vname_set;
*swig_vdevice_get = *LibStoragec::ContVolInfo_vdevice_get;
*swig_vdevice_set = *LibStoragec::ContVolInfo_vdevice_set;
*swig_num_get = *LibStoragec::ContVolInfo_num_get;
*swig_num_set = *LibStoragec::ContVolInfo_num_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_ContVolInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::PartitionSlotInfo ##############

package LibStorage::PartitionSlotInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_PartitionSlotInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_cylStart_get = *LibStoragec::PartitionSlotInfo_cylStart_get;
*swig_cylStart_set = *LibStoragec::PartitionSlotInfo_cylStart_set;
*swig_cylSize_get = *LibStoragec::PartitionSlotInfo_cylSize_get;
*swig_cylSize_set = *LibStoragec::PartitionSlotInfo_cylSize_set;
*swig_primarySlot_get = *LibStoragec::PartitionSlotInfo_primarySlot_get;
*swig_primarySlot_set = *LibStoragec::PartitionSlotInfo_primarySlot_set;
*swig_primaryPossible_get = *LibStoragec::PartitionSlotInfo_primaryPossible_get;
*swig_primaryPossible_set = *LibStoragec::PartitionSlotInfo_primaryPossible_set;
*swig_extendedSlot_get = *LibStoragec::PartitionSlotInfo_extendedSlot_get;
*swig_extendedSlot_set = *LibStoragec::PartitionSlotInfo_extendedSlot_set;
*swig_extendedPossible_get = *LibStoragec::PartitionSlotInfo_extendedPossible_get;
*swig_extendedPossible_set = *LibStoragec::PartitionSlotInfo_extendedPossible_set;
*swig_logicalSlot_get = *LibStoragec::PartitionSlotInfo_logicalSlot_get;
*swig_logicalSlot_set = *LibStoragec::PartitionSlotInfo_logicalSlot_set;
*swig_logicalPossible_get = *LibStoragec::PartitionSlotInfo_logicalPossible_get;
*swig_logicalPossible_set = *LibStoragec::PartitionSlotInfo_logicalPossible_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_PartitionSlotInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::CommitInfo ##############

package LibStorage::CommitInfo;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_CommitInfo(@_);
    bless $self, $pkg if defined($self);
}

*swig_destructive_get = *LibStoragec::CommitInfo_destructive_get;
*swig_destructive_set = *LibStoragec::CommitInfo_destructive_set;
*swig_text_get = *LibStoragec::CommitInfo_text_get;
*swig_text_set = *LibStoragec::CommitInfo_text_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_CommitInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::StorageInterface ##############

package LibStorage::StorageInterface;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_StorageInterface($self);
        delete $OWNER{$self};
    }
}

*getContainers = *LibStoragec::StorageInterface_getContainers;
*getDiskInfo = *LibStoragec::StorageInterface_getDiskInfo;
*getContDiskInfo = *LibStoragec::StorageInterface_getContDiskInfo;
*getLvmVgInfo = *LibStoragec::StorageInterface_getLvmVgInfo;
*getContLvmVgInfo = *LibStoragec::StorageInterface_getContLvmVgInfo;
*getDmraidCoInfo = *LibStoragec::StorageInterface_getDmraidCoInfo;
*getContDmraidCoInfo = *LibStoragec::StorageInterface_getContDmraidCoInfo;
*getDmmultipathCoInfo = *LibStoragec::StorageInterface_getDmmultipathCoInfo;
*getContDmmultipathCoInfo = *LibStoragec::StorageInterface_getContDmmultipathCoInfo;
*getMdPartCoInfo = *LibStoragec::StorageInterface_getMdPartCoInfo;
*getContMdPartCoInfo = *LibStoragec::StorageInterface_getContMdPartCoInfo;
*setImsmDriver = *LibStoragec::StorageInterface_setImsmDriver;
*getImsmDriver = *LibStoragec::StorageInterface_getImsmDriver;
*setMultipathAutostart = *LibStoragec::StorageInterface_setMultipathAutostart;
*getMultipathAutostart = *LibStoragec::StorageInterface_getMultipathAutostart;
*getVolumes = *LibStoragec::StorageInterface_getVolumes;
*getVolume = *LibStoragec::StorageInterface_getVolume;
*getPartitionInfo = *LibStoragec::StorageInterface_getPartitionInfo;
*getLvmLvInfo = *LibStoragec::StorageInterface_getLvmLvInfo;
*getMdInfo = *LibStoragec::StorageInterface_getMdInfo;
*getMdPartInfo = *LibStoragec::StorageInterface_getMdPartInfo;
*getNfsInfo = *LibStoragec::StorageInterface_getNfsInfo;
*getLoopInfo = *LibStoragec::StorageInterface_getLoopInfo;
*getDmInfo = *LibStoragec::StorageInterface_getDmInfo;
*getBtrfsInfo = *LibStoragec::StorageInterface_getBtrfsInfo;
*getTmpfsInfo = *LibStoragec::StorageInterface_getTmpfsInfo;
*getDmraidInfo = *LibStoragec::StorageInterface_getDmraidInfo;
*getDmmultipathInfo = *LibStoragec::StorageInterface_getDmmultipathInfo;
*getFsCapabilities = *LibStoragec::StorageInterface_getFsCapabilities;
*getDlabelCapabilities = *LibStoragec::StorageInterface_getDlabelCapabilities;
*getAllUsedFs = *LibStoragec::StorageInterface_getAllUsedFs;
*createPartition = *LibStoragec::StorageInterface_createPartition;
*resizePartition = *LibStoragec::StorageInterface_resizePartition;
*resizePartitionNoFs = *LibStoragec::StorageInterface_resizePartitionNoFs;
*updatePartitionArea = *LibStoragec::StorageInterface_updatePartitionArea;
*freeCylindersAroundPartition = *LibStoragec::StorageInterface_freeCylindersAroundPartition;
*nextFreePartition = *LibStoragec::StorageInterface_nextFreePartition;
*createPartitionKb = *LibStoragec::StorageInterface_createPartitionKb;
*createPartitionAny = *LibStoragec::StorageInterface_createPartitionAny;
*createPartitionMax = *LibStoragec::StorageInterface_createPartitionMax;
*cylinderToKb = *LibStoragec::StorageInterface_cylinderToKb;
*kbToCylinder = *LibStoragec::StorageInterface_kbToCylinder;
*removePartition = *LibStoragec::StorageInterface_removePartition;
*changePartitionId = *LibStoragec::StorageInterface_changePartitionId;
*forgetChangePartitionId = *LibStoragec::StorageInterface_forgetChangePartitionId;
*getPartitionPrefix = *LibStoragec::StorageInterface_getPartitionPrefix;
*getPartitionName = *LibStoragec::StorageInterface_getPartitionName;
*getUnusedPartitionSlots = *LibStoragec::StorageInterface_getUnusedPartitionSlots;
*destroyPartitionTable = *LibStoragec::StorageInterface_destroyPartitionTable;
*initializeDisk = *LibStoragec::StorageInterface_initializeDisk;
*defaultDiskLabel = *LibStoragec::StorageInterface_defaultDiskLabel;
*changeFormatVolume = *LibStoragec::StorageInterface_changeFormatVolume;
*changeLabelVolume = *LibStoragec::StorageInterface_changeLabelVolume;
*changeMkfsOptVolume = *LibStoragec::StorageInterface_changeMkfsOptVolume;
*changeTunefsOptVolume = *LibStoragec::StorageInterface_changeTunefsOptVolume;
*changeMountPoint = *LibStoragec::StorageInterface_changeMountPoint;
*getMountPoint = *LibStoragec::StorageInterface_getMountPoint;
*changeMountBy = *LibStoragec::StorageInterface_changeMountBy;
*getMountBy = *LibStoragec::StorageInterface_getMountBy;
*changeFstabOptions = *LibStoragec::StorageInterface_changeFstabOptions;
*getFstabOptions = *LibStoragec::StorageInterface_getFstabOptions;
*addFstabOptions = *LibStoragec::StorageInterface_addFstabOptions;
*removeFstabOptions = *LibStoragec::StorageInterface_removeFstabOptions;
*setCryptPassword = *LibStoragec::StorageInterface_setCryptPassword;
*forgetCryptPassword = *LibStoragec::StorageInterface_forgetCryptPassword;
*getCryptPassword = *LibStoragec::StorageInterface_getCryptPassword;
*verifyCryptPassword = *LibStoragec::StorageInterface_verifyCryptPassword;
*needCryptPassword = *LibStoragec::StorageInterface_needCryptPassword;
*setCrypt = *LibStoragec::StorageInterface_setCrypt;
*setCryptType = *LibStoragec::StorageInterface_setCryptType;
*getCrypt = *LibStoragec::StorageInterface_getCrypt;
*setIgnoreFstab = *LibStoragec::StorageInterface_setIgnoreFstab;
*getIgnoreFstab = *LibStoragec::StorageInterface_getIgnoreFstab;
*changeDescText = *LibStoragec::StorageInterface_changeDescText;
*addFstabEntry = *LibStoragec::StorageInterface_addFstabEntry;
*resizeVolume = *LibStoragec::StorageInterface_resizeVolume;
*resizeVolumeNoFs = *LibStoragec::StorageInterface_resizeVolumeNoFs;
*forgetResizeVolume = *LibStoragec::StorageInterface_forgetResizeVolume;
*setRecursiveRemoval = *LibStoragec::StorageInterface_setRecursiveRemoval;
*getRecursiveRemoval = *LibStoragec::StorageInterface_getRecursiveRemoval;
*getRecursiveUsing = *LibStoragec::StorageInterface_getRecursiveUsing;
*getRecursiveUsedBy = *LibStoragec::StorageInterface_getRecursiveUsedBy;
*setZeroNewPartitions = *LibStoragec::StorageInterface_setZeroNewPartitions;
*getZeroNewPartitions = *LibStoragec::StorageInterface_getZeroNewPartitions;
*setPartitionAlignment = *LibStoragec::StorageInterface_setPartitionAlignment;
*getPartitionAlignment = *LibStoragec::StorageInterface_getPartitionAlignment;
*setDefaultMountBy = *LibStoragec::StorageInterface_setDefaultMountBy;
*getDefaultMountBy = *LibStoragec::StorageInterface_getDefaultMountBy;
*setDefaultFs = *LibStoragec::StorageInterface_setDefaultFs;
*getDefaultFs = *LibStoragec::StorageInterface_getDefaultFs;
*setDefaultSubvolName = *LibStoragec::StorageInterface_setDefaultSubvolName;
*getDefaultSubvolName = *LibStoragec::StorageInterface_getDefaultSubvolName;
*getEfiBoot = *LibStoragec::StorageInterface_getEfiBoot;
*setRootPrefix = *LibStoragec::StorageInterface_setRootPrefix;
*getRootPrefix = *LibStoragec::StorageInterface_getRootPrefix;
*setDetectMountedVolumes = *LibStoragec::StorageInterface_setDetectMountedVolumes;
*getDetectMountedVolumes = *LibStoragec::StorageInterface_getDetectMountedVolumes;
*removeVolume = *LibStoragec::StorageInterface_removeVolume;
*createLvmVg = *LibStoragec::StorageInterface_createLvmVg;
*removeLvmVg = *LibStoragec::StorageInterface_removeLvmVg;
*extendLvmVg = *LibStoragec::StorageInterface_extendLvmVg;
*shrinkLvmVg = *LibStoragec::StorageInterface_shrinkLvmVg;
*createLvmLv = *LibStoragec::StorageInterface_createLvmLv;
*removeLvmLvByDevice = *LibStoragec::StorageInterface_removeLvmLvByDevice;
*removeLvmLv = *LibStoragec::StorageInterface_removeLvmLv;
*changeLvStripeCount = *LibStoragec::StorageInterface_changeLvStripeCount;
*changeLvStripeSize = *LibStoragec::StorageInterface_changeLvStripeSize;
*createLvmLvSnapshot = *LibStoragec::StorageInterface_createLvmLvSnapshot;
*removeLvmLvSnapshot = *LibStoragec::StorageInterface_removeLvmLvSnapshot;
*getLvmLvSnapshotStateInfo = *LibStoragec::StorageInterface_getLvmLvSnapshotStateInfo;
*createLvmLvPool = *LibStoragec::StorageInterface_createLvmLvPool;
*createLvmLvThin = *LibStoragec::StorageInterface_createLvmLvThin;
*changeLvChunkSize = *LibStoragec::StorageInterface_changeLvChunkSize;
*nextFreeMd = *LibStoragec::StorageInterface_nextFreeMd;
*createMd = *LibStoragec::StorageInterface_createMd;
*createMdAny = *LibStoragec::StorageInterface_createMdAny;
*removeMd = *LibStoragec::StorageInterface_removeMd;
*extendMd = *LibStoragec::StorageInterface_extendMd;
*updateMd = *LibStoragec::StorageInterface_updateMd;
*shrinkMd = *LibStoragec::StorageInterface_shrinkMd;
*changeMdType = *LibStoragec::StorageInterface_changeMdType;
*changeMdChunk = *LibStoragec::StorageInterface_changeMdChunk;
*changeMdParity = *LibStoragec::StorageInterface_changeMdParity;
*checkMd = *LibStoragec::StorageInterface_checkMd;
*getMdStateInfo = *LibStoragec::StorageInterface_getMdStateInfo;
*getMdPartCoStateInfo = *LibStoragec::StorageInterface_getMdPartCoStateInfo;
*computeMdSize = *LibStoragec::StorageInterface_computeMdSize;
*getMdAllowedParity = *LibStoragec::StorageInterface_getMdAllowedParity;
*removeMdPartCo = *LibStoragec::StorageInterface_removeMdPartCo;
*addNfsDevice = *LibStoragec::StorageInterface_addNfsDevice;
*checkNfsDevice = *LibStoragec::StorageInterface_checkNfsDevice;
*createFileLoop = *LibStoragec::StorageInterface_createFileLoop;
*modifyFileLoop = *LibStoragec::StorageInterface_modifyFileLoop;
*removeFileLoop = *LibStoragec::StorageInterface_removeFileLoop;
*removeDmraid = *LibStoragec::StorageInterface_removeDmraid;
*existSubvolume = *LibStoragec::StorageInterface_existSubvolume;
*createSubvolume = *LibStoragec::StorageInterface_createSubvolume;
*removeSubvolume = *LibStoragec::StorageInterface_removeSubvolume;
*extendBtrfsVolume = *LibStoragec::StorageInterface_extendBtrfsVolume;
*shrinkBtrfsVolume = *LibStoragec::StorageInterface_shrinkBtrfsVolume;
*addTmpfsMount = *LibStoragec::StorageInterface_addTmpfsMount;
*removeTmpfsMount = *LibStoragec::StorageInterface_removeTmpfsMount;
*getCommitInfos = *LibStoragec::StorageInterface_getCommitInfos;
*getLastAction = *LibStoragec::StorageInterface_getLastAction;
*getExtendedErrorMessage = *LibStoragec::StorageInterface_getExtendedErrorMessage;
*setCacheChanges = *LibStoragec::StorageInterface_setCacheChanges;
*isCacheChanges = *LibStoragec::StorageInterface_isCacheChanges;
*commit = *LibStoragec::StorageInterface_commit;
*getErrorString = *LibStoragec::StorageInterface_getErrorString;
*createBackupState = *LibStoragec::StorageInterface_createBackupState;
*restoreBackupState = *LibStoragec::StorageInterface_restoreBackupState;
*checkBackupState = *LibStoragec::StorageInterface_checkBackupState;
*equalBackupStates = *LibStoragec::StorageInterface_equalBackupStates;
*removeBackupState = *LibStoragec::StorageInterface_removeBackupState;
*checkDeviceMounted = *LibStoragec::StorageInterface_checkDeviceMounted;
*umountDevice = *LibStoragec::StorageInterface_umountDevice;
*umountDeviceUns = *LibStoragec::StorageInterface_umountDeviceUns;
*mountDevice = *LibStoragec::StorageInterface_mountDevice;
*activateEncryption = *LibStoragec::StorageInterface_activateEncryption;
*mountDeviceOpts = *LibStoragec::StorageInterface_mountDeviceOpts;
*mountDeviceRo = *LibStoragec::StorageInterface_mountDeviceRo;
*checkDmMapsTo = *LibStoragec::StorageInterface_checkDmMapsTo;
*removeDmTableTo = *LibStoragec::StorageInterface_removeDmTableTo;
*renameCryptDm = *LibStoragec::StorageInterface_renameCryptDm;
*getFreeInfo = *LibStoragec::StorageInterface_getFreeInfo;
*readFstab = *LibStoragec::StorageInterface_readFstab;
*activateHld = *LibStoragec::StorageInterface_activateHld;
*activateMultipath = *LibStoragec::StorageInterface_activateMultipath;
*rescanEverything = *LibStoragec::StorageInterface_rescanEverything;
*rescanCryptedObjects = *LibStoragec::StorageInterface_rescanCryptedObjects;
*dumpObjectList = *LibStoragec::StorageInterface_dumpObjectList;
*dumpCommitInfos = *LibStoragec::StorageInterface_dumpCommitInfos;
*getContVolInfo = *LibStoragec::StorageInterface_getContVolInfo;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : LibStorage::Environment ##############

package LibStorage::Environment;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( LibStorage );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = LibStoragec::new_Environment(@_);
    bless $self, $pkg if defined($self);
}

*swig_readonly_get = *LibStoragec::Environment_readonly_get;
*swig_readonly_set = *LibStoragec::Environment_readonly_set;
*swig_testmode_get = *LibStoragec::Environment_testmode_get;
*swig_testmode_set = *LibStoragec::Environment_testmode_set;
*swig_autodetect_get = *LibStoragec::Environment_autodetect_get;
*swig_autodetect_set = *LibStoragec::Environment_autodetect_set;
*swig_instsys_get = *LibStoragec::Environment_instsys_get;
*swig_instsys_set = *LibStoragec::Environment_instsys_set;
*swig_logdir_get = *LibStoragec::Environment_logdir_get;
*swig_logdir_set = *LibStoragec::Environment_logdir_set;
*swig_testdir_get = *LibStoragec::Environment_testdir_get;
*swig_testdir_set = *LibStoragec::Environment_testdir_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        LibStoragec::delete_Environment($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package LibStorage;

*FSUNKNOWN = *LibStoragec::FSUNKNOWN;
*REISERFS = *LibStoragec::REISERFS;
*EXT2 = *LibStoragec::EXT2;
*EXT3 = *LibStoragec::EXT3;
*EXT4 = *LibStoragec::EXT4;
*BTRFS = *LibStoragec::BTRFS;
*VFAT = *LibStoragec::VFAT;
*XFS = *LibStoragec::XFS;
*JFS = *LibStoragec::JFS;
*HFS = *LibStoragec::HFS;
*NTFS = *LibStoragec::NTFS;
*SWAP = *LibStoragec::SWAP;
*HFSPLUS = *LibStoragec::HFSPLUS;
*NFS = *LibStoragec::NFS;
*NFS4 = *LibStoragec::NFS4;
*TMPFS = *LibStoragec::TMPFS;
*FSNONE = *LibStoragec::FSNONE;
*PRIMARY = *LibStoragec::PRIMARY;
*EXTENDED = *LibStoragec::EXTENDED;
*LOGICAL = *LibStoragec::LOGICAL;
*PTYPE_ANY = *LibStoragec::PTYPE_ANY;
*MOUNTBY_DEVICE = *LibStoragec::MOUNTBY_DEVICE;
*MOUNTBY_UUID = *LibStoragec::MOUNTBY_UUID;
*MOUNTBY_LABEL = *LibStoragec::MOUNTBY_LABEL;
*MOUNTBY_ID = *LibStoragec::MOUNTBY_ID;
*MOUNTBY_PATH = *LibStoragec::MOUNTBY_PATH;
*ENC_NONE = *LibStoragec::ENC_NONE;
*ENC_TWOFISH = *LibStoragec::ENC_TWOFISH;
*ENC_TWOFISH_OLD = *LibStoragec::ENC_TWOFISH_OLD;
*ENC_TWOFISH256_OLD = *LibStoragec::ENC_TWOFISH256_OLD;
*ENC_LUKS = *LibStoragec::ENC_LUKS;
*ENC_UNKNOWN = *LibStoragec::ENC_UNKNOWN;
*RAID_UNK = *LibStoragec::RAID_UNK;
*RAID0 = *LibStoragec::RAID0;
*RAID1 = *LibStoragec::RAID1;
*RAID5 = *LibStoragec::RAID5;
*RAID6 = *LibStoragec::RAID6;
*RAID10 = *LibStoragec::RAID10;
*MULTIPATH = *LibStoragec::MULTIPATH;
*PAR_DEFAULT = *LibStoragec::PAR_DEFAULT;
*LEFT_ASYMMETRIC = *LibStoragec::LEFT_ASYMMETRIC;
*LEFT_SYMMETRIC = *LibStoragec::LEFT_SYMMETRIC;
*RIGHT_ASYMMETRIC = *LibStoragec::RIGHT_ASYMMETRIC;
*RIGHT_SYMMETRIC = *LibStoragec::RIGHT_SYMMETRIC;
*PAR_FIRST = *LibStoragec::PAR_FIRST;
*PAR_LAST = *LibStoragec::PAR_LAST;
*LEFT_ASYMMETRIC_6 = *LibStoragec::LEFT_ASYMMETRIC_6;
*LEFT_SYMMETRIC_6 = *LibStoragec::LEFT_SYMMETRIC_6;
*RIGHT_ASYMMETRIC_6 = *LibStoragec::RIGHT_ASYMMETRIC_6;
*RIGHT_SYMMETRIC_6 = *LibStoragec::RIGHT_SYMMETRIC_6;
*PAR_FIRST_6 = *LibStoragec::PAR_FIRST_6;
*PAR_NEAR_2 = *LibStoragec::PAR_NEAR_2;
*PAR_OFFSET_2 = *LibStoragec::PAR_OFFSET_2;
*PAR_FAR_2 = *LibStoragec::PAR_FAR_2;
*PAR_NEAR_3 = *LibStoragec::PAR_NEAR_3;
*PAR_OFFSET_3 = *LibStoragec::PAR_OFFSET_3;
*PAR_FAR_3 = *LibStoragec::PAR_FAR_3;
*UNKNOWN = *LibStoragec::UNKNOWN;
*CLEAR = *LibStoragec::CLEAR;
*INACTIVE = *LibStoragec::INACTIVE;
*SUSPENDED = *LibStoragec::SUSPENDED;
*READONLY = *LibStoragec::READONLY;
*READ_AUTO = *LibStoragec::READ_AUTO;
*CLEAN = *LibStoragec::CLEAN;
*ACTIVE = *LibStoragec::ACTIVE;
*WRITE_PENDING = *LibStoragec::WRITE_PENDING;
*ACTIVE_IDLE = *LibStoragec::ACTIVE_IDLE;
*UB_NONE = *LibStoragec::UB_NONE;
*UB_LVM = *LibStoragec::UB_LVM;
*UB_MD = *LibStoragec::UB_MD;
*UB_MDPART = *LibStoragec::UB_MDPART;
*UB_DM = *LibStoragec::UB_DM;
*UB_DMRAID = *LibStoragec::UB_DMRAID;
*UB_DMMULTIPATH = *LibStoragec::UB_DMMULTIPATH;
*UB_BTRFS = *LibStoragec::UB_BTRFS;
*CUNKNOWN = *LibStoragec::CUNKNOWN;
*DISK = *LibStoragec::DISK;
*MD = *LibStoragec::MD;
*LOOP = *LibStoragec::LOOP;
*LVM = *LibStoragec::LVM;
*DM = *LibStoragec::DM;
*DMRAID = *LibStoragec::DMRAID;
*NFSC = *LibStoragec::NFSC;
*DMMULTIPATH = *LibStoragec::DMMULTIPATH;
*MDPART = *LibStoragec::MDPART;
*BTRFSC = *LibStoragec::BTRFSC;
*TMPFSC = *LibStoragec::TMPFSC;
*TUNKNOWN = *LibStoragec::TUNKNOWN;
*SBP = *LibStoragec::SBP;
*ATA = *LibStoragec::ATA;
*FC = *LibStoragec::FC;
*ISCSI = *LibStoragec::ISCSI;
*SAS = *LibStoragec::SAS;
*SATA = *LibStoragec::SATA;
*SPI = *LibStoragec::SPI;
*USB = *LibStoragec::USB;
*FCOE = *LibStoragec::FCOE;
*IMSM_UNDECIDED = *LibStoragec::IMSM_UNDECIDED;
*IMSM_DMRAID = *LibStoragec::IMSM_DMRAID;
*IMSM_MDADM = *LibStoragec::IMSM_MDADM;
*MPAS_UNDECIDED = *LibStoragec::MPAS_UNDECIDED;
*MPAS_ON = *LibStoragec::MPAS_ON;
*MPAS_OFF = *LibStoragec::MPAS_OFF;
*ALIGN_OPTIMAL = *LibStoragec::ALIGN_OPTIMAL;
*ALIGN_CYLINDER = *LibStoragec::ALIGN_CYLINDER;
*STORAGE_NO_ERROR = *LibStoragec::STORAGE_NO_ERROR;
*DISK_PARTITION_OVERLAPS_EXISTING = *LibStoragec::DISK_PARTITION_OVERLAPS_EXISTING;
*DISK_PARTITION_EXCEEDS_DISK = *LibStoragec::DISK_PARTITION_EXCEEDS_DISK;
*DISK_CREATE_PARTITION_EXT_ONLY_ONCE = *LibStoragec::DISK_CREATE_PARTITION_EXT_ONLY_ONCE;
*DISK_CREATE_PARTITION_EXT_IMPOSSIBLE = *LibStoragec::DISK_CREATE_PARTITION_EXT_IMPOSSIBLE;
*DISK_PARTITION_NO_FREE_NUMBER = *LibStoragec::DISK_PARTITION_NO_FREE_NUMBER;
*DISK_CREATE_PARTITION_INVALID_VOLUME = *LibStoragec::DISK_CREATE_PARTITION_INVALID_VOLUME;
*DISK_CREATE_PARTITION_INVALID_TYPE = *LibStoragec::DISK_CREATE_PARTITION_INVALID_TYPE;
*DISK_CREATE_PARTITION_PARTED_FAILED = *LibStoragec::DISK_CREATE_PARTITION_PARTED_FAILED;
*DISK_PARTITION_NOT_FOUND = *LibStoragec::DISK_PARTITION_NOT_FOUND;
*DISK_CREATE_PARTITION_LOGICAL_NO_EXT = *LibStoragec::DISK_CREATE_PARTITION_LOGICAL_NO_EXT;
*DISK_PARTITION_LOGICAL_OUTSIDE_EXT = *LibStoragec::DISK_PARTITION_LOGICAL_OUTSIDE_EXT;
*DISK_SET_TYPE_INVALID_VOLUME = *LibStoragec::DISK_SET_TYPE_INVALID_VOLUME;
*DISK_SET_TYPE_PARTED_FAILED = *LibStoragec::DISK_SET_TYPE_PARTED_FAILED;
*DISK_SET_LABEL_PARTED_FAILED = *LibStoragec::DISK_SET_LABEL_PARTED_FAILED;
*DISK_REMOVE_PARTITION_PARTED_FAILED = *LibStoragec::DISK_REMOVE_PARTITION_PARTED_FAILED;
*DISK_REMOVE_PARTITION_INVALID_VOLUME = *LibStoragec::DISK_REMOVE_PARTITION_INVALID_VOLUME;
*DISK_REMOVE_PARTITION_LIST_ERASE = *LibStoragec::DISK_REMOVE_PARTITION_LIST_ERASE;
*DISK_DESTROY_TABLE_INVALID_LABEL = *LibStoragec::DISK_DESTROY_TABLE_INVALID_LABEL;
*DISK_PARTITION_ZERO_SIZE = *LibStoragec::DISK_PARTITION_ZERO_SIZE;
*DISK_CHANGE_READONLY = *LibStoragec::DISK_CHANGE_READONLY;
*DISK_RESIZE_PARTITION_INVALID_VOLUME = *LibStoragec::DISK_RESIZE_PARTITION_INVALID_VOLUME;
*DISK_RESIZE_PARTITION_PARTED_FAILED = *LibStoragec::DISK_RESIZE_PARTITION_PARTED_FAILED;
*DISK_RESIZE_NO_SPACE = *LibStoragec::DISK_RESIZE_NO_SPACE;
*DISK_CHECK_RESIZE_INVALID_VOLUME = *LibStoragec::DISK_CHECK_RESIZE_INVALID_VOLUME;
*DISK_REMOVE_PARTITION_CREATE_NOT_FOUND = *LibStoragec::DISK_REMOVE_PARTITION_CREATE_NOT_FOUND;
*DISK_COMMIT_NOTHING_TODO = *LibStoragec::DISK_COMMIT_NOTHING_TODO;
*DISK_CREATE_PARTITION_NO_SPACE = *LibStoragec::DISK_CREATE_PARTITION_NO_SPACE;
*DISK_REMOVE_USED_BY = *LibStoragec::DISK_REMOVE_USED_BY;
*DISK_INIT_NOT_POSSIBLE = *LibStoragec::DISK_INIT_NOT_POSSIBLE;
*DISK_INVALID_PARTITION_ID = *LibStoragec::DISK_INVALID_PARTITION_ID;
*STORAGE_DISK_NOT_FOUND = *LibStoragec::STORAGE_DISK_NOT_FOUND;
*STORAGE_VOLUME_NOT_FOUND = *LibStoragec::STORAGE_VOLUME_NOT_FOUND;
*STORAGE_REMOVE_PARTITION_INVALID_CONTAINER = *LibStoragec::STORAGE_REMOVE_PARTITION_INVALID_CONTAINER;
*STORAGE_CHANGE_PARTITION_ID_INVALID_CONTAINER = *LibStoragec::STORAGE_CHANGE_PARTITION_ID_INVALID_CONTAINER;
*STORAGE_CHANGE_READONLY = *LibStoragec::STORAGE_CHANGE_READONLY;
*STORAGE_DISK_USED_BY = *LibStoragec::STORAGE_DISK_USED_BY;
*STORAGE_LVM_VG_EXISTS = *LibStoragec::STORAGE_LVM_VG_EXISTS;
*STORAGE_LVM_VG_NOT_FOUND = *LibStoragec::STORAGE_LVM_VG_NOT_FOUND;
*STORAGE_LVM_INVALID_DEVICE = *LibStoragec::STORAGE_LVM_INVALID_DEVICE;
*STORAGE_CONTAINER_NOT_FOUND = *LibStoragec::STORAGE_CONTAINER_NOT_FOUND;
*STORAGE_VG_INVALID_NAME = *LibStoragec::STORAGE_VG_INVALID_NAME;
*STORAGE_REMOVE_USED_VOLUME = *LibStoragec::STORAGE_REMOVE_USED_VOLUME;
*STORAGE_REMOVE_USING_UNKNOWN_TYPE = *LibStoragec::STORAGE_REMOVE_USING_UNKNOWN_TYPE;
*STORAGE_NOT_YET_IMPLEMENTED = *LibStoragec::STORAGE_NOT_YET_IMPLEMENTED;
*STORAGE_MD_INVALID_NAME = *LibStoragec::STORAGE_MD_INVALID_NAME;
*STORAGE_MD_NOT_FOUND = *LibStoragec::STORAGE_MD_NOT_FOUND;
*STORAGE_MEMORY_EXHAUSTED = *LibStoragec::STORAGE_MEMORY_EXHAUSTED;
*STORAGE_LOOP_NOT_FOUND = *LibStoragec::STORAGE_LOOP_NOT_FOUND;
*STORAGE_CREATED_LOOP_NOT_FOUND = *LibStoragec::STORAGE_CREATED_LOOP_NOT_FOUND;
*STORAGE_CHANGE_AREA_INVALID_CONTAINER = *LibStoragec::STORAGE_CHANGE_AREA_INVALID_CONTAINER;
*STORAGE_BACKUP_STATE_NOT_FOUND = *LibStoragec::STORAGE_BACKUP_STATE_NOT_FOUND;
*STORAGE_INVALID_FSTAB_VALUE = *LibStoragec::STORAGE_INVALID_FSTAB_VALUE;
*STORAGE_NO_FSTAB_PTR = *LibStoragec::STORAGE_NO_FSTAB_PTR;
*STORAGE_DEVICE_NODE_NOT_FOUND = *LibStoragec::STORAGE_DEVICE_NODE_NOT_FOUND;
*STORAGE_DMRAID_CO_NOT_FOUND = *LibStoragec::STORAGE_DMRAID_CO_NOT_FOUND;
*STORAGE_RESIZE_INVALID_CONTAINER = *LibStoragec::STORAGE_RESIZE_INVALID_CONTAINER;
*STORAGE_DMMULTIPATH_CO_NOT_FOUND = *LibStoragec::STORAGE_DMMULTIPATH_CO_NOT_FOUND;
*STORAGE_ZERO_DEVICE_FAILED = *LibStoragec::STORAGE_ZERO_DEVICE_FAILED;
*STORAGE_INVALID_BACKUP_STATE_NAME = *LibStoragec::STORAGE_INVALID_BACKUP_STATE_NAME;
*STORAGE_MDPART_CO_NOT_FOUND = *LibStoragec::STORAGE_MDPART_CO_NOT_FOUND;
*STORAGE_DEVICE_NOT_FOUND = *LibStoragec::STORAGE_DEVICE_NOT_FOUND;
*STORAGE_BTRFS_CO_NOT_FOUND = *LibStoragec::STORAGE_BTRFS_CO_NOT_FOUND;
*STORAGE_TMPFS_CO_NOT_FOUND = *LibStoragec::STORAGE_TMPFS_CO_NOT_FOUND;
*STORAGE_VOLUME_NOT_ENCRYPTED = *LibStoragec::STORAGE_VOLUME_NOT_ENCRYPTED;
*STORAGE_DM_RENAME_FAILED = *LibStoragec::STORAGE_DM_RENAME_FAILED;
*VOLUME_COMMIT_UNKNOWN_STAGE = *LibStoragec::VOLUME_COMMIT_UNKNOWN_STAGE;
*VOLUME_FSTAB_EMPTY_MOUNT = *LibStoragec::VOLUME_FSTAB_EMPTY_MOUNT;
*VOLUME_UMOUNT_FAILED = *LibStoragec::VOLUME_UMOUNT_FAILED;
*VOLUME_MOUNT_FAILED = *LibStoragec::VOLUME_MOUNT_FAILED;
*VOLUME_FORMAT_UNKNOWN_FS = *LibStoragec::VOLUME_FORMAT_UNKNOWN_FS;
*VOLUME_FORMAT_FS_UNDETECTED = *LibStoragec::VOLUME_FORMAT_FS_UNDETECTED;
*VOLUME_FORMAT_FS_TOO_SMALL = *LibStoragec::VOLUME_FORMAT_FS_TOO_SMALL;
*VOLUME_FORMAT_FAILED = *LibStoragec::VOLUME_FORMAT_FAILED;
*VOLUME_TUNE2FS_FAILED = *LibStoragec::VOLUME_TUNE2FS_FAILED;
*VOLUME_MKLABEL_FS_UNABLE = *LibStoragec::VOLUME_MKLABEL_FS_UNABLE;
*VOLUME_MKLABEL_FAILED = *LibStoragec::VOLUME_MKLABEL_FAILED;
*VOLUME_LOSETUP_NO_LOOP = *LibStoragec::VOLUME_LOSETUP_NO_LOOP;
*VOLUME_LOSETUP_FAILED = *LibStoragec::VOLUME_LOSETUP_FAILED;
*VOLUME_CRYPT_NO_PWD = *LibStoragec::VOLUME_CRYPT_NO_PWD;
*VOLUME_CRYPT_PWD_TOO_SHORT = *LibStoragec::VOLUME_CRYPT_PWD_TOO_SHORT;
*VOLUME_CRYPT_NOT_DETECTED = *LibStoragec::VOLUME_CRYPT_NOT_DETECTED;
*VOLUME_FORMAT_EXTENDED_UNSUPPORTED = *LibStoragec::VOLUME_FORMAT_EXTENDED_UNSUPPORTED;
*VOLUME_MOUNT_EXTENDED_UNSUPPORTED = *LibStoragec::VOLUME_MOUNT_EXTENDED_UNSUPPORTED;
*VOLUME_MOUNT_POINT_INVALID = *LibStoragec::VOLUME_MOUNT_POINT_INVALID;
*VOLUME_MOUNTBY_NOT_ENCRYPTED = *LibStoragec::VOLUME_MOUNTBY_NOT_ENCRYPTED;
*VOLUME_MOUNTBY_UNSUPPORTED_BY_FS = *LibStoragec::VOLUME_MOUNTBY_UNSUPPORTED_BY_FS;
*VOLUME_LABEL_NOT_SUPPORTED = *LibStoragec::VOLUME_LABEL_NOT_SUPPORTED;
*VOLUME_LABEL_TOO_LONG = *LibStoragec::VOLUME_LABEL_TOO_LONG;
*VOLUME_LABEL_WHILE_MOUNTED = *LibStoragec::VOLUME_LABEL_WHILE_MOUNTED;
*VOLUME_RESIZE_UNSUPPORTED_BY_FS = *LibStoragec::VOLUME_RESIZE_UNSUPPORTED_BY_FS;
*VOLUME_RESIZE_UNSUPPORTED_BY_CONTAINER = *LibStoragec::VOLUME_RESIZE_UNSUPPORTED_BY_CONTAINER;
*VOLUME_RESIZE_FAILED = *LibStoragec::VOLUME_RESIZE_FAILED;
*VOLUME_ALREADY_IN_USE = *LibStoragec::VOLUME_ALREADY_IN_USE;
*VOLUME_LOUNSETUP_FAILED = *LibStoragec::VOLUME_LOUNSETUP_FAILED;
*VOLUME_DEVICE_NOT_PRESENT = *LibStoragec::VOLUME_DEVICE_NOT_PRESENT;
*VOLUME_DEVICE_NOT_BLOCK = *LibStoragec::VOLUME_DEVICE_NOT_BLOCK;
*VOLUME_MOUNTBY_UNSUPPORTED_BY_VOLUME = *LibStoragec::VOLUME_MOUNTBY_UNSUPPORTED_BY_VOLUME;
*VOLUME_CRYPTFORMAT_FAILED = *LibStoragec::VOLUME_CRYPTFORMAT_FAILED;
*VOLUME_CRYPTSETUP_FAILED = *LibStoragec::VOLUME_CRYPTSETUP_FAILED;
*VOLUME_CRYPTUNSETUP_FAILED = *LibStoragec::VOLUME_CRYPTUNSETUP_FAILED;
*VOLUME_FORMAT_NOT_IMPLEMENTED = *LibStoragec::VOLUME_FORMAT_NOT_IMPLEMENTED;
*VOLUME_FORMAT_IMPOSSIBLE = *LibStoragec::VOLUME_FORMAT_IMPOSSIBLE;
*VOLUME_CRYPT_NFS_IMPOSSIBLE = *LibStoragec::VOLUME_CRYPT_NFS_IMPOSSIBLE;
*VOLUME_REMOUNT_FAILED = *LibStoragec::VOLUME_REMOUNT_FAILED;
*VOLUME_TUNEREISERFS_FAILED = *LibStoragec::VOLUME_TUNEREISERFS_FAILED;
*VOLUME_UMOUNT_NOT_MOUNTED = *LibStoragec::VOLUME_UMOUNT_NOT_MOUNTED;
*VOLUME_BTRFS_ADD_FAILED = *LibStoragec::VOLUME_BTRFS_ADD_FAILED;
*VOLUME_CANNOT_TMP_MOUNT = *LibStoragec::VOLUME_CANNOT_TMP_MOUNT;
*VOLUME_CANNOT_TMP_UMOUNT = *LibStoragec::VOLUME_CANNOT_TMP_UMOUNT;
*VOLUME_BTRFS_SUBVOL_INIT_FAILED = *LibStoragec::VOLUME_BTRFS_SUBVOL_INIT_FAILED;
*VOLUME_BTRFS_SUBVOL_DETDEFAULT = *LibStoragec::VOLUME_BTRFS_SUBVOL_DETDEFAULT;
*LVM_CREATE_PV_FAILED = *LibStoragec::LVM_CREATE_PV_FAILED;
*LVM_PV_ALREADY_CONTAINED = *LibStoragec::LVM_PV_ALREADY_CONTAINED;
*LVM_PV_DEVICE_UNKNOWN = *LibStoragec::LVM_PV_DEVICE_UNKNOWN;
*LVM_PV_DEVICE_USED = *LibStoragec::LVM_PV_DEVICE_USED;
*LVM_VG_HAS_NONE_PV = *LibStoragec::LVM_VG_HAS_NONE_PV;
*LVM_LV_INVALID_NAME = *LibStoragec::LVM_LV_INVALID_NAME;
*LVM_LV_DUPLICATE_NAME = *LibStoragec::LVM_LV_DUPLICATE_NAME;
*LVM_LV_NO_SPACE = *LibStoragec::LVM_LV_NO_SPACE;
*LVM_LV_UNKNOWN_NAME = *LibStoragec::LVM_LV_UNKNOWN_NAME;
*LVM_LV_NOT_IN_LIST = *LibStoragec::LVM_LV_NOT_IN_LIST;
*LVM_VG_CREATE_FAILED = *LibStoragec::LVM_VG_CREATE_FAILED;
*LVM_VG_EXTEND_FAILED = *LibStoragec::LVM_VG_EXTEND_FAILED;
*LVM_VG_REDUCE_FAILED = *LibStoragec::LVM_VG_REDUCE_FAILED;
*LVM_VG_REMOVE_FAILED = *LibStoragec::LVM_VG_REMOVE_FAILED;
*LVM_LV_CREATE_FAILED = *LibStoragec::LVM_LV_CREATE_FAILED;
*LVM_LV_REMOVE_FAILED = *LibStoragec::LVM_LV_REMOVE_FAILED;
*LVM_LV_RESIZE_FAILED = *LibStoragec::LVM_LV_RESIZE_FAILED;
*LVM_PV_STILL_ADDED = *LibStoragec::LVM_PV_STILL_ADDED;
*LVM_PV_REMOVE_NOT_FOUND = *LibStoragec::LVM_PV_REMOVE_NOT_FOUND;
*LVM_CREATE_LV_INVALID_VOLUME = *LibStoragec::LVM_CREATE_LV_INVALID_VOLUME;
*LVM_REMOVE_LV_INVALID_VOLUME = *LibStoragec::LVM_REMOVE_LV_INVALID_VOLUME;
*LVM_RESIZE_LV_INVALID_VOLUME = *LibStoragec::LVM_RESIZE_LV_INVALID_VOLUME;
*LVM_CHANGE_READONLY = *LibStoragec::LVM_CHANGE_READONLY;
*LVM_CHECK_RESIZE_INVALID_VOLUME = *LibStoragec::LVM_CHECK_RESIZE_INVALID_VOLUME;
*LVM_COMMIT_NOTHING_TODO = *LibStoragec::LVM_COMMIT_NOTHING_TODO;
*LVM_LV_REMOVE_USED_BY = *LibStoragec::LVM_LV_REMOVE_USED_BY;
*LVM_LV_ALREADY_ON_DISK = *LibStoragec::LVM_LV_ALREADY_ON_DISK;
*LVM_LV_NO_STRIPE_SIZE = *LibStoragec::LVM_LV_NO_STRIPE_SIZE;
*LVM_LV_UNKNOWN_ORIGIN = *LibStoragec::LVM_LV_UNKNOWN_ORIGIN;
*LVM_LV_NOT_ON_DISK = *LibStoragec::LVM_LV_NOT_ON_DISK;
*LVM_LV_NOT_SNAPSHOT = *LibStoragec::LVM_LV_NOT_SNAPSHOT;
*LVM_LV_HAS_SNAPSHOTS = *LibStoragec::LVM_LV_HAS_SNAPSHOTS;
*LVM_LV_IS_SNAPSHOT = *LibStoragec::LVM_LV_IS_SNAPSHOT;
*LVM_LIST_EMPTY = *LibStoragec::LVM_LIST_EMPTY;
*LVM_LV_NO_POOL_OR_SNAP = *LibStoragec::LVM_LV_NO_POOL_OR_SNAP;
*LVM_LV_NO_POOL = *LibStoragec::LVM_LV_NO_POOL;
*LVM_LV_UNKNOWN_POOL = *LibStoragec::LVM_LV_UNKNOWN_POOL;
*LVM_LV_INVALID_CHUNK_SIZE = *LibStoragec::LVM_LV_INVALID_CHUNK_SIZE;
*LVM_LV_POOL_NO_FORMAT = *LibStoragec::LVM_LV_POOL_NO_FORMAT;
*LVM_LV_POOL_NO_MOUNT = *LibStoragec::LVM_LV_POOL_NO_MOUNT;
*FSTAB_ENTRY_NOT_FOUND = *LibStoragec::FSTAB_ENTRY_NOT_FOUND;
*FSTAB_CHANGE_PREFIX_IMPOSSIBLE = *LibStoragec::FSTAB_CHANGE_PREFIX_IMPOSSIBLE;
*FSTAB_REMOVE_ENTRY_NOT_FOUND = *LibStoragec::FSTAB_REMOVE_ENTRY_NOT_FOUND;
*FSTAB_UPDATE_ENTRY_NOT_FOUND = *LibStoragec::FSTAB_UPDATE_ENTRY_NOT_FOUND;
*FSTAB_ADD_ENTRY_FOUND = *LibStoragec::FSTAB_ADD_ENTRY_FOUND;
*MD_CHANGE_READONLY = *LibStoragec::MD_CHANGE_READONLY;
*MD_DUPLICATE_NUMBER = *LibStoragec::MD_DUPLICATE_NUMBER;
*MD_TOO_FEW_DEVICES = *LibStoragec::MD_TOO_FEW_DEVICES;
*MD_DEVICE_UNKNOWN = *LibStoragec::MD_DEVICE_UNKNOWN;
*MD_DEVICE_USED = *LibStoragec::MD_DEVICE_USED;
*MD_CREATE_INVALID_VOLUME = *LibStoragec::MD_CREATE_INVALID_VOLUME;
*MD_REMOVE_FAILED = *LibStoragec::MD_REMOVE_FAILED;
*MD_NOT_IN_LIST = *LibStoragec::MD_NOT_IN_LIST;
*MD_CREATE_FAILED = *LibStoragec::MD_CREATE_FAILED;
*MD_UNKNOWN_NUMBER = *LibStoragec::MD_UNKNOWN_NUMBER;
*MD_REMOVE_USED_BY = *LibStoragec::MD_REMOVE_USED_BY;
*MD_NUMBER_TOO_LARGE = *LibStoragec::MD_NUMBER_TOO_LARGE;
*MD_REMOVE_INVALID_VOLUME = *LibStoragec::MD_REMOVE_INVALID_VOLUME;
*MD_REMOVE_CREATE_NOT_FOUND = *LibStoragec::MD_REMOVE_CREATE_NOT_FOUND;
*MD_NO_RESIZE_ON_DISK = *LibStoragec::MD_NO_RESIZE_ON_DISK;
*MD_ADD_DUPLICATE = *LibStoragec::MD_ADD_DUPLICATE;
*MD_REMOVE_NONEXISTENT = *LibStoragec::MD_REMOVE_NONEXISTENT;
*MD_NO_CHANGE_ON_DISK = *LibStoragec::MD_NO_CHANGE_ON_DISK;
*MD_NO_CREATE_UNKNOWN = *LibStoragec::MD_NO_CREATE_UNKNOWN;
*MD_STATE_NOT_ON_DISK = *LibStoragec::MD_STATE_NOT_ON_DISK;
*MD_PARTITION_NOT_FOUND = *LibStoragec::MD_PARTITION_NOT_FOUND;
*MD_INVALID_PARITY = *LibStoragec::MD_INVALID_PARITY;
*MD_TOO_MANY_SPARES = *LibStoragec::MD_TOO_MANY_SPARES;
*MD_GET_STATE_FAILED = *LibStoragec::MD_GET_STATE_FAILED;
*MDPART_CHANGE_READONLY = *LibStoragec::MDPART_CHANGE_READONLY;
*MDPART_INTERNAL_ERR = *LibStoragec::MDPART_INTERNAL_ERR;
*MDPART_INVALID_VOLUME = *LibStoragec::MDPART_INVALID_VOLUME;
*MDPART_PARTITION_NOT_FOUND = *LibStoragec::MDPART_PARTITION_NOT_FOUND;
*MDPART_REMOVE_PARTITION_LIST_ERASE = *LibStoragec::MDPART_REMOVE_PARTITION_LIST_ERASE;
*MDPART_COMMIT_NOTHING_TODO = *LibStoragec::MDPART_COMMIT_NOTHING_TODO;
*MDPART_NO_REMOVE = *LibStoragec::MDPART_NO_REMOVE;
*MDPART_DEVICE_NOT_FOUND = *LibStoragec::MDPART_DEVICE_NOT_FOUND;
*LOOP_CHANGE_READONLY = *LibStoragec::LOOP_CHANGE_READONLY;
*LOOP_DUPLICATE_FILE = *LibStoragec::LOOP_DUPLICATE_FILE;
*LOOP_UNKNOWN_FILE = *LibStoragec::LOOP_UNKNOWN_FILE;
*LOOP_REMOVE_USED_BY = *LibStoragec::LOOP_REMOVE_USED_BY;
*LOOP_FILE_CREATE_FAILED = *LibStoragec::LOOP_FILE_CREATE_FAILED;
*LOOP_CREATE_INVALID_VOLUME = *LibStoragec::LOOP_CREATE_INVALID_VOLUME;
*LOOP_REMOVE_FILE_FAILED = *LibStoragec::LOOP_REMOVE_FILE_FAILED;
*LOOP_REMOVE_INVALID_VOLUME = *LibStoragec::LOOP_REMOVE_INVALID_VOLUME;
*LOOP_NOT_IN_LIST = *LibStoragec::LOOP_NOT_IN_LIST;
*LOOP_REMOVE_CREATE_NOT_FOUND = *LibStoragec::LOOP_REMOVE_CREATE_NOT_FOUND;
*LOOP_MODIFY_EXISTING = *LibStoragec::LOOP_MODIFY_EXISTING;
*PEC_PE_SIZE_INVALID = *LibStoragec::PEC_PE_SIZE_INVALID;
*PEC_PV_NOT_FOUND = *LibStoragec::PEC_PV_NOT_FOUND;
*PEC_REMOVE_PV_IN_USE = *LibStoragec::PEC_REMOVE_PV_IN_USE;
*PEC_REMOVE_PV_SIZE_NEEDED = *LibStoragec::PEC_REMOVE_PV_SIZE_NEEDED;
*PEC_LV_NO_SPACE_STRIPED = *LibStoragec::PEC_LV_NO_SPACE_STRIPED;
*PEC_LV_NO_SPACE_SINGLE = *LibStoragec::PEC_LV_NO_SPACE_SINGLE;
*PEC_LV_PE_DEV_NOT_FOUND = *LibStoragec::PEC_LV_PE_DEV_NOT_FOUND;
*DM_CHANGE_READONLY = *LibStoragec::DM_CHANGE_READONLY;
*DM_UNKNOWN_TABLE = *LibStoragec::DM_UNKNOWN_TABLE;
*DM_REMOVE_USED_BY = *LibStoragec::DM_REMOVE_USED_BY;
*DM_REMOVE_CREATE_NOT_FOUND = *LibStoragec::DM_REMOVE_CREATE_NOT_FOUND;
*DM_REMOVE_INVALID_VOLUME = *LibStoragec::DM_REMOVE_INVALID_VOLUME;
*DM_REMOVE_FAILED = *LibStoragec::DM_REMOVE_FAILED;
*DM_NOT_IN_LIST = *LibStoragec::DM_NOT_IN_LIST;
*DASD_NOT_POSSIBLE = *LibStoragec::DASD_NOT_POSSIBLE;
*DASD_FDASD_FAILED = *LibStoragec::DASD_FDASD_FAILED;
*DASD_DASDFMT_FAILED = *LibStoragec::DASD_DASDFMT_FAILED;
*DMPART_CHANGE_READONLY = *LibStoragec::DMPART_CHANGE_READONLY;
*DMPART_INTERNAL_ERR = *LibStoragec::DMPART_INTERNAL_ERR;
*DMPART_INVALID_VOLUME = *LibStoragec::DMPART_INVALID_VOLUME;
*DMPART_PARTITION_NOT_FOUND = *LibStoragec::DMPART_PARTITION_NOT_FOUND;
*DMPART_REMOVE_PARTITION_LIST_ERASE = *LibStoragec::DMPART_REMOVE_PARTITION_LIST_ERASE;
*DMPART_COMMIT_NOTHING_TODO = *LibStoragec::DMPART_COMMIT_NOTHING_TODO;
*DMPART_NO_REMOVE = *LibStoragec::DMPART_NO_REMOVE;
*DMRAID_REMOVE_FAILED = *LibStoragec::DMRAID_REMOVE_FAILED;
*NFS_VOLUME_NOT_FOUND = *LibStoragec::NFS_VOLUME_NOT_FOUND;
*NFS_CHANGE_READONLY = *LibStoragec::NFS_CHANGE_READONLY;
*NFS_REMOVE_VOLUME_CREATE_NOT_FOUND = *LibStoragec::NFS_REMOVE_VOLUME_CREATE_NOT_FOUND;
*NFS_REMOVE_VOLUME_LIST_ERASE = *LibStoragec::NFS_REMOVE_VOLUME_LIST_ERASE;
*NFS_REMOVE_INVALID_VOLUME = *LibStoragec::NFS_REMOVE_INVALID_VOLUME;
*BTRFS_COMMIT_INVALID_VOLUME = *LibStoragec::BTRFS_COMMIT_INVALID_VOLUME;
*BTRFS_CANNOT_TMP_MOUNT = *LibStoragec::BTRFS_CANNOT_TMP_MOUNT;
*BTRFS_CANNOT_TMP_UMOUNT = *LibStoragec::BTRFS_CANNOT_TMP_UMOUNT;
*BTRFS_DELETE_SUBVOL_FAIL = *LibStoragec::BTRFS_DELETE_SUBVOL_FAIL;
*BTRFS_CREATE_SUBVOL_FAIL = *LibStoragec::BTRFS_CREATE_SUBVOL_FAIL;
*BTRFS_VOLUME_NOT_FOUND = *LibStoragec::BTRFS_VOLUME_NOT_FOUND;
*BTRFS_SUBVOL_EXISTS = *LibStoragec::BTRFS_SUBVOL_EXISTS;
*BTRFS_SUBVOL_NON_EXISTS = *LibStoragec::BTRFS_SUBVOL_NON_EXISTS;
*BTRFS_REMOVE_NOT_FOUND = *LibStoragec::BTRFS_REMOVE_NOT_FOUND;
*BTRFS_REMOVE_NO_BTRFS = *LibStoragec::BTRFS_REMOVE_NO_BTRFS;
*BTRFS_REMOVE_INVALID_VOLUME = *LibStoragec::BTRFS_REMOVE_INVALID_VOLUME;
*BTRFS_CHANGE_READONLY = *LibStoragec::BTRFS_CHANGE_READONLY;
*BTRFS_DEV_ALREADY_CONTAINED = *LibStoragec::BTRFS_DEV_ALREADY_CONTAINED;
*BTRFS_DEVICE_UNKNOWN = *LibStoragec::BTRFS_DEVICE_UNKNOWN;
*BTRFS_DEVICE_USED = *LibStoragec::BTRFS_DEVICE_USED;
*BTRFS_HAS_NONE_DEV = *LibStoragec::BTRFS_HAS_NONE_DEV;
*BTRFS_DEV_NOT_FOUND = *LibStoragec::BTRFS_DEV_NOT_FOUND;
*BTRFS_EXTEND_FAIL = *LibStoragec::BTRFS_EXTEND_FAIL;
*BTRFS_REDUCE_FAIL = *LibStoragec::BTRFS_REDUCE_FAIL;
*BTRFS_LIST_EMPTY = *LibStoragec::BTRFS_LIST_EMPTY;
*BTRFS_RESIZE_INVALID_VOLUME = *LibStoragec::BTRFS_RESIZE_INVALID_VOLUME;
*BTRFS_MULTIDEV_SHRINK_UNSUPPORTED = *LibStoragec::BTRFS_MULTIDEV_SHRINK_UNSUPPORTED;
*TMPFS_REMOVE_INVALID_VOLUME = *LibStoragec::TMPFS_REMOVE_INVALID_VOLUME;
*TMPFS_REMOVE_NO_TMPFS = *LibStoragec::TMPFS_REMOVE_NO_TMPFS;
*TMPFS_REMOVE_NOT_FOUND = *LibStoragec::TMPFS_REMOVE_NOT_FOUND;
*CONTAINER_INTERNAL_ERROR = *LibStoragec::CONTAINER_INTERNAL_ERROR;
*CONTAINER_INVALID_VIRTUAL_CALL = *LibStoragec::CONTAINER_INVALID_VIRTUAL_CALL;
1;
package LibStorage;
BEGIN {
    %TYPEINFO = (
        ALL_METHODS => 0,
        initDefaultLogger => ["function", "void"],
        initDefaultLogger => ["function", "void", "&string"],
        setLogDoCallback => ["function", "void", "any"],
        getLogDoCallback => ["function", "any"],
        setLogQueryCallback => ["function", "void", "any"],
        getLogQueryCallback => ["function", "any"],
        createStorageInterface => ["function", "any", "any"],
        createStorageInterfacePid => ["function", "any", "any", "&integer"],
        destroyStorageInterface => ["function", "void", "any"],
        numSuffixes => ["function", "integer"],
        getSuffix => ["function", "string", "integer", "boolean"],
        byteToHumanString => ["function", "string", "integer", "boolean", "integer", "boolean"],
        humanStringToByte => ["function", "boolean", "&string", "boolean", "&integer"],
        saveDeviceGraph => ["function", "boolean", "any", "&string"],
        saveMountGraph => ["function", "boolean", "any", "&string"],
    );
}

BEGIN{$TYPEINFO{FSUNKNOWN}=["function", "integer"]}
*FSUNKNOWN = sub { $LibStoragec::FSUNKNOWN };
BEGIN{$TYPEINFO{REISERFS}=["function", "integer"]}
*REISERFS = sub { $LibStoragec::REISERFS };
BEGIN{$TYPEINFO{EXT2}=["function", "integer"]}
*EXT2 = sub { $LibStoragec::EXT2 };
BEGIN{$TYPEINFO{EXT3}=["function", "integer"]}
*EXT3 = sub { $LibStoragec::EXT3 };
BEGIN{$TYPEINFO{EXT4}=["function", "integer"]}
*EXT4 = sub { $LibStoragec::EXT4 };
BEGIN{$TYPEINFO{BTRFS}=["function", "integer"]}
*BTRFS = sub { $LibStoragec::BTRFS };
BEGIN{$TYPEINFO{VFAT}=["function", "integer"]}
*VFAT = sub { $LibStoragec::VFAT };
BEGIN{$TYPEINFO{XFS}=["function", "integer"]}
*XFS = sub { $LibStoragec::XFS };
BEGIN{$TYPEINFO{JFS}=["function", "integer"]}
*JFS = sub { $LibStoragec::JFS };
BEGIN{$TYPEINFO{HFS}=["function", "integer"]}
*HFS = sub { $LibStoragec::HFS };
BEGIN{$TYPEINFO{NTFS}=["function", "integer"]}
*NTFS = sub { $LibStoragec::NTFS };
BEGIN{$TYPEINFO{SWAP}=["function", "integer"]}
*SWAP = sub { $LibStoragec::SWAP };
BEGIN{$TYPEINFO{HFSPLUS}=["function", "integer"]}
*HFSPLUS = sub { $LibStoragec::HFSPLUS };
BEGIN{$TYPEINFO{NFS}=["function", "integer"]}
*NFS = sub { $LibStoragec::NFS };
BEGIN{$TYPEINFO{NFS4}=["function", "integer"]}
*NFS4 = sub { $LibStoragec::NFS4 };
BEGIN{$TYPEINFO{TMPFS}=["function", "integer"]}
*TMPFS = sub { $LibStoragec::TMPFS };
BEGIN{$TYPEINFO{FSNONE}=["function", "integer"]}
*FSNONE = sub { $LibStoragec::FSNONE };

BEGIN{$TYPEINFO{PRIMARY}=["function", "integer"]}
*PRIMARY = sub { $LibStoragec::PRIMARY };
BEGIN{$TYPEINFO{EXTENDED}=["function", "integer"]}
*EXTENDED = sub { $LibStoragec::EXTENDED };
BEGIN{$TYPEINFO{LOGICAL}=["function", "integer"]}
*LOGICAL = sub { $LibStoragec::LOGICAL };
BEGIN{$TYPEINFO{PTYPE_ANY}=["function", "integer"]}
*PTYPE_ANY = sub { $LibStoragec::PTYPE_ANY };

BEGIN{$TYPEINFO{MOUNTBY_DEVICE}=["function", "integer"]}
*MOUNTBY_DEVICE = sub { $LibStoragec::MOUNTBY_DEVICE };
BEGIN{$TYPEINFO{MOUNTBY_UUID}=["function", "integer"]}
*MOUNTBY_UUID = sub { $LibStoragec::MOUNTBY_UUID };
BEGIN{$TYPEINFO{MOUNTBY_LABEL}=["function", "integer"]}
*MOUNTBY_LABEL = sub { $LibStoragec::MOUNTBY_LABEL };
BEGIN{$TYPEINFO{MOUNTBY_ID}=["function", "integer"]}
*MOUNTBY_ID = sub { $LibStoragec::MOUNTBY_ID };
BEGIN{$TYPEINFO{MOUNTBY_PATH}=["function", "integer"]}
*MOUNTBY_PATH = sub { $LibStoragec::MOUNTBY_PATH };

BEGIN{$TYPEINFO{ENC_NONE}=["function", "integer"]}
*ENC_NONE = sub { $LibStoragec::ENC_NONE };
BEGIN{$TYPEINFO{ENC_TWOFISH}=["function", "integer"]}
*ENC_TWOFISH = sub { $LibStoragec::ENC_TWOFISH };
BEGIN{$TYPEINFO{ENC_TWOFISH_OLD}=["function", "integer"]}
*ENC_TWOFISH_OLD = sub { $LibStoragec::ENC_TWOFISH_OLD };
BEGIN{$TYPEINFO{ENC_TWOFISH256_OLD}=["function", "integer"]}
*ENC_TWOFISH256_OLD = sub { $LibStoragec::ENC_TWOFISH256_OLD };
BEGIN{$TYPEINFO{ENC_LUKS}=["function", "integer"]}
*ENC_LUKS = sub { $LibStoragec::ENC_LUKS };
BEGIN{$TYPEINFO{ENC_UNKNOWN}=["function", "integer"]}
*ENC_UNKNOWN = sub { $LibStoragec::ENC_UNKNOWN };

BEGIN{$TYPEINFO{RAID_UNK}=["function", "integer"]}
*RAID_UNK = sub { $LibStoragec::RAID_UNK };
BEGIN{$TYPEINFO{RAID0}=["function", "integer"]}
*RAID0 = sub { $LibStoragec::RAID0 };
BEGIN{$TYPEINFO{RAID1}=["function", "integer"]}
*RAID1 = sub { $LibStoragec::RAID1 };
BEGIN{$TYPEINFO{RAID5}=["function", "integer"]}
*RAID5 = sub { $LibStoragec::RAID5 };
BEGIN{$TYPEINFO{RAID6}=["function", "integer"]}
*RAID6 = sub { $LibStoragec::RAID6 };
BEGIN{$TYPEINFO{RAID10}=["function", "integer"]}
*RAID10 = sub { $LibStoragec::RAID10 };
BEGIN{$TYPEINFO{MULTIPATH}=["function", "integer"]}
*MULTIPATH = sub { $LibStoragec::MULTIPATH };

BEGIN{$TYPEINFO{PAR_DEFAULT}=["function", "integer"]}
*PAR_DEFAULT = sub { $LibStoragec::PAR_DEFAULT };
BEGIN{$TYPEINFO{LEFT_ASYMMETRIC}=["function", "integer"]}
*LEFT_ASYMMETRIC = sub { $LibStoragec::LEFT_ASYMMETRIC };
BEGIN{$TYPEINFO{LEFT_SYMMETRIC}=["function", "integer"]}
*LEFT_SYMMETRIC = sub { $LibStoragec::LEFT_SYMMETRIC };
BEGIN{$TYPEINFO{RIGHT_ASYMMETRIC}=["function", "integer"]}
*RIGHT_ASYMMETRIC = sub { $LibStoragec::RIGHT_ASYMMETRIC };
BEGIN{$TYPEINFO{RIGHT_SYMMETRIC}=["function", "integer"]}
*RIGHT_SYMMETRIC = sub { $LibStoragec::RIGHT_SYMMETRIC };
BEGIN{$TYPEINFO{PAR_FIRST}=["function", "integer"]}
*PAR_FIRST = sub { $LibStoragec::PAR_FIRST };
BEGIN{$TYPEINFO{PAR_LAST}=["function", "integer"]}
*PAR_LAST = sub { $LibStoragec::PAR_LAST };
BEGIN{$TYPEINFO{LEFT_ASYMMETRIC_6}=["function", "integer"]}
*LEFT_ASYMMETRIC_6 = sub { $LibStoragec::LEFT_ASYMMETRIC_6 };
BEGIN{$TYPEINFO{LEFT_SYMMETRIC_6}=["function", "integer"]}
*LEFT_SYMMETRIC_6 = sub { $LibStoragec::LEFT_SYMMETRIC_6 };
BEGIN{$TYPEINFO{RIGHT_ASYMMETRIC_6}=["function", "integer"]}
*RIGHT_ASYMMETRIC_6 = sub { $LibStoragec::RIGHT_ASYMMETRIC_6 };
BEGIN{$TYPEINFO{RIGHT_SYMMETRIC_6}=["function", "integer"]}
*RIGHT_SYMMETRIC_6 = sub { $LibStoragec::RIGHT_SYMMETRIC_6 };
BEGIN{$TYPEINFO{PAR_FIRST_6}=["function", "integer"]}
*PAR_FIRST_6 = sub { $LibStoragec::PAR_FIRST_6 };
BEGIN{$TYPEINFO{PAR_NEAR_2}=["function", "integer"]}
*PAR_NEAR_2 = sub { $LibStoragec::PAR_NEAR_2 };
BEGIN{$TYPEINFO{PAR_OFFSET_2}=["function", "integer"]}
*PAR_OFFSET_2 = sub { $LibStoragec::PAR_OFFSET_2 };
BEGIN{$TYPEINFO{PAR_FAR_2}=["function", "integer"]}
*PAR_FAR_2 = sub { $LibStoragec::PAR_FAR_2 };
BEGIN{$TYPEINFO{PAR_NEAR_3}=["function", "integer"]}
*PAR_NEAR_3 = sub { $LibStoragec::PAR_NEAR_3 };
BEGIN{$TYPEINFO{PAR_OFFSET_3}=["function", "integer"]}
*PAR_OFFSET_3 = sub { $LibStoragec::PAR_OFFSET_3 };
BEGIN{$TYPEINFO{PAR_FAR_3}=["function", "integer"]}
*PAR_FAR_3 = sub { $LibStoragec::PAR_FAR_3 };

BEGIN{$TYPEINFO{UNKNOWN}=["function", "integer"]}
*UNKNOWN = sub { $LibStoragec::UNKNOWN };
BEGIN{$TYPEINFO{CLEAR}=["function", "integer"]}
*CLEAR = sub { $LibStoragec::CLEAR };
BEGIN{$TYPEINFO{INACTIVE}=["function", "integer"]}
*INACTIVE = sub { $LibStoragec::INACTIVE };
BEGIN{$TYPEINFO{SUSPENDED}=["function", "integer"]}
*SUSPENDED = sub { $LibStoragec::SUSPENDED };
BEGIN{$TYPEINFO{READONLY}=["function", "integer"]}
*READONLY = sub { $LibStoragec::READONLY };
BEGIN{$TYPEINFO{READ_AUTO}=["function", "integer"]}
*READ_AUTO = sub { $LibStoragec::READ_AUTO };
BEGIN{$TYPEINFO{CLEAN}=["function", "integer"]}
*CLEAN = sub { $LibStoragec::CLEAN };
BEGIN{$TYPEINFO{ACTIVE}=["function", "integer"]}
*ACTIVE = sub { $LibStoragec::ACTIVE };
BEGIN{$TYPEINFO{WRITE_PENDING}=["function", "integer"]}
*WRITE_PENDING = sub { $LibStoragec::WRITE_PENDING };
BEGIN{$TYPEINFO{ACTIVE_IDLE}=["function", "integer"]}
*ACTIVE_IDLE = sub { $LibStoragec::ACTIVE_IDLE };

BEGIN{$TYPEINFO{UB_NONE}=["function", "integer"]}
*UB_NONE = sub { $LibStoragec::UB_NONE };
BEGIN{$TYPEINFO{UB_LVM}=["function", "integer"]}
*UB_LVM = sub { $LibStoragec::UB_LVM };
BEGIN{$TYPEINFO{UB_MD}=["function", "integer"]}
*UB_MD = sub { $LibStoragec::UB_MD };
BEGIN{$TYPEINFO{UB_MDPART}=["function", "integer"]}
*UB_MDPART = sub { $LibStoragec::UB_MDPART };
BEGIN{$TYPEINFO{UB_DM}=["function", "integer"]}
*UB_DM = sub { $LibStoragec::UB_DM };
BEGIN{$TYPEINFO{UB_DMRAID}=["function", "integer"]}
*UB_DMRAID = sub { $LibStoragec::UB_DMRAID };
BEGIN{$TYPEINFO{UB_DMMULTIPATH}=["function", "integer"]}
*UB_DMMULTIPATH = sub { $LibStoragec::UB_DMMULTIPATH };
BEGIN{$TYPEINFO{UB_BTRFS}=["function", "integer"]}
*UB_BTRFS = sub { $LibStoragec::UB_BTRFS };

BEGIN{$TYPEINFO{CUNKNOWN}=["function", "integer"]}
*CUNKNOWN = sub { $LibStoragec::CUNKNOWN };
BEGIN{$TYPEINFO{DISK}=["function", "integer"]}
*DISK = sub { $LibStoragec::DISK };
BEGIN{$TYPEINFO{MD}=["function", "integer"]}
*MD = sub { $LibStoragec::MD };
BEGIN{$TYPEINFO{LOOP}=["function", "integer"]}
*LOOP = sub { $LibStoragec::LOOP };
BEGIN{$TYPEINFO{LVM}=["function", "integer"]}
*LVM = sub { $LibStoragec::LVM };
BEGIN{$TYPEINFO{DM}=["function", "integer"]}
*DM = sub { $LibStoragec::DM };
BEGIN{$TYPEINFO{DMRAID}=["function", "integer"]}
*DMRAID = sub { $LibStoragec::DMRAID };
BEGIN{$TYPEINFO{NFSC}=["function", "integer"]}
*NFSC = sub { $LibStoragec::NFSC };
BEGIN{$TYPEINFO{DMMULTIPATH}=["function", "integer"]}
*DMMULTIPATH = sub { $LibStoragec::DMMULTIPATH };
BEGIN{$TYPEINFO{MDPART}=["function", "integer"]}
*MDPART = sub { $LibStoragec::MDPART };
BEGIN{$TYPEINFO{BTRFSC}=["function", "integer"]}
*BTRFSC = sub { $LibStoragec::BTRFSC };
BEGIN{$TYPEINFO{TMPFSC}=["function", "integer"]}
*TMPFSC = sub { $LibStoragec::TMPFSC };

BEGIN{$TYPEINFO{TUNKNOWN}=["function", "integer"]}
*TUNKNOWN = sub { $LibStoragec::TUNKNOWN };
BEGIN{$TYPEINFO{SBP}=["function", "integer"]}
*SBP = sub { $LibStoragec::SBP };
BEGIN{$TYPEINFO{ATA}=["function", "integer"]}
*ATA = sub { $LibStoragec::ATA };
BEGIN{$TYPEINFO{FC}=["function", "integer"]}
*FC = sub { $LibStoragec::FC };
BEGIN{$TYPEINFO{ISCSI}=["function", "integer"]}
*ISCSI = sub { $LibStoragec::ISCSI };
BEGIN{$TYPEINFO{SAS}=["function", "integer"]}
*SAS = sub { $LibStoragec::SAS };
BEGIN{$TYPEINFO{SATA}=["function", "integer"]}
*SATA = sub { $LibStoragec::SATA };
BEGIN{$TYPEINFO{SPI}=["function", "integer"]}
*SPI = sub { $LibStoragec::SPI };
BEGIN{$TYPEINFO{USB}=["function", "integer"]}
*USB = sub { $LibStoragec::USB };
BEGIN{$TYPEINFO{FCOE}=["function", "integer"]}
*FCOE = sub { $LibStoragec::FCOE };

BEGIN{$TYPEINFO{IMSM_UNDECIDED}=["function", "integer"]}
*IMSM_UNDECIDED = sub { $LibStoragec::IMSM_UNDECIDED };
BEGIN{$TYPEINFO{IMSM_DMRAID}=["function", "integer"]}
*IMSM_DMRAID = sub { $LibStoragec::IMSM_DMRAID };
BEGIN{$TYPEINFO{IMSM_MDADM}=["function", "integer"]}
*IMSM_MDADM = sub { $LibStoragec::IMSM_MDADM };

BEGIN{$TYPEINFO{MPAS_UNDECIDED}=["function", "integer"]}
*MPAS_UNDECIDED = sub { $LibStoragec::MPAS_UNDECIDED };
BEGIN{$TYPEINFO{MPAS_ON}=["function", "integer"]}
*MPAS_ON = sub { $LibStoragec::MPAS_ON };
BEGIN{$TYPEINFO{MPAS_OFF}=["function", "integer"]}
*MPAS_OFF = sub { $LibStoragec::MPAS_OFF };

BEGIN{$TYPEINFO{ALIGN_OPTIMAL}=["function", "integer"]}
*ALIGN_OPTIMAL = sub { $LibStoragec::ALIGN_OPTIMAL };
BEGIN{$TYPEINFO{ALIGN_CYLINDER}=["function", "integer"]}
*ALIGN_CYLINDER = sub { $LibStoragec::ALIGN_CYLINDER };

BEGIN{$TYPEINFO{STORAGE_NO_ERROR}=["function", "integer"]}
*STORAGE_NO_ERROR = sub { $LibStoragec::STORAGE_NO_ERROR };
BEGIN{$TYPEINFO{DISK_PARTITION_OVERLAPS_EXISTING}=["function", "integer"]}
*DISK_PARTITION_OVERLAPS_EXISTING = sub { $LibStoragec::DISK_PARTITION_OVERLAPS_EXISTING };
BEGIN{$TYPEINFO{DISK_PARTITION_EXCEEDS_DISK}=["function", "integer"]}
*DISK_PARTITION_EXCEEDS_DISK = sub { $LibStoragec::DISK_PARTITION_EXCEEDS_DISK };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_EXT_ONLY_ONCE}=["function", "integer"]}
*DISK_CREATE_PARTITION_EXT_ONLY_ONCE = sub { $LibStoragec::DISK_CREATE_PARTITION_EXT_ONLY_ONCE };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_EXT_IMPOSSIBLE}=["function", "integer"]}
*DISK_CREATE_PARTITION_EXT_IMPOSSIBLE = sub { $LibStoragec::DISK_CREATE_PARTITION_EXT_IMPOSSIBLE };
BEGIN{$TYPEINFO{DISK_PARTITION_NO_FREE_NUMBER}=["function", "integer"]}
*DISK_PARTITION_NO_FREE_NUMBER = sub { $LibStoragec::DISK_PARTITION_NO_FREE_NUMBER };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_INVALID_VOLUME}=["function", "integer"]}
*DISK_CREATE_PARTITION_INVALID_VOLUME = sub { $LibStoragec::DISK_CREATE_PARTITION_INVALID_VOLUME };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_INVALID_TYPE}=["function", "integer"]}
*DISK_CREATE_PARTITION_INVALID_TYPE = sub { $LibStoragec::DISK_CREATE_PARTITION_INVALID_TYPE };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_PARTED_FAILED}=["function", "integer"]}
*DISK_CREATE_PARTITION_PARTED_FAILED = sub { $LibStoragec::DISK_CREATE_PARTITION_PARTED_FAILED };
BEGIN{$TYPEINFO{DISK_PARTITION_NOT_FOUND}=["function", "integer"]}
*DISK_PARTITION_NOT_FOUND = sub { $LibStoragec::DISK_PARTITION_NOT_FOUND };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_LOGICAL_NO_EXT}=["function", "integer"]}
*DISK_CREATE_PARTITION_LOGICAL_NO_EXT = sub { $LibStoragec::DISK_CREATE_PARTITION_LOGICAL_NO_EXT };
BEGIN{$TYPEINFO{DISK_PARTITION_LOGICAL_OUTSIDE_EXT}=["function", "integer"]}
*DISK_PARTITION_LOGICAL_OUTSIDE_EXT = sub { $LibStoragec::DISK_PARTITION_LOGICAL_OUTSIDE_EXT };
BEGIN{$TYPEINFO{DISK_SET_TYPE_INVALID_VOLUME}=["function", "integer"]}
*DISK_SET_TYPE_INVALID_VOLUME = sub { $LibStoragec::DISK_SET_TYPE_INVALID_VOLUME };
BEGIN{$TYPEINFO{DISK_SET_TYPE_PARTED_FAILED}=["function", "integer"]}
*DISK_SET_TYPE_PARTED_FAILED = sub { $LibStoragec::DISK_SET_TYPE_PARTED_FAILED };
BEGIN{$TYPEINFO{DISK_SET_LABEL_PARTED_FAILED}=["function", "integer"]}
*DISK_SET_LABEL_PARTED_FAILED = sub { $LibStoragec::DISK_SET_LABEL_PARTED_FAILED };
BEGIN{$TYPEINFO{DISK_REMOVE_PARTITION_PARTED_FAILED}=["function", "integer"]}
*DISK_REMOVE_PARTITION_PARTED_FAILED = sub { $LibStoragec::DISK_REMOVE_PARTITION_PARTED_FAILED };
BEGIN{$TYPEINFO{DISK_REMOVE_PARTITION_INVALID_VOLUME}=["function", "integer"]}
*DISK_REMOVE_PARTITION_INVALID_VOLUME = sub { $LibStoragec::DISK_REMOVE_PARTITION_INVALID_VOLUME };
BEGIN{$TYPEINFO{DISK_REMOVE_PARTITION_LIST_ERASE}=["function", "integer"]}
*DISK_REMOVE_PARTITION_LIST_ERASE = sub { $LibStoragec::DISK_REMOVE_PARTITION_LIST_ERASE };
BEGIN{$TYPEINFO{DISK_DESTROY_TABLE_INVALID_LABEL}=["function", "integer"]}
*DISK_DESTROY_TABLE_INVALID_LABEL = sub { $LibStoragec::DISK_DESTROY_TABLE_INVALID_LABEL };
BEGIN{$TYPEINFO{DISK_PARTITION_ZERO_SIZE}=["function", "integer"]}
*DISK_PARTITION_ZERO_SIZE = sub { $LibStoragec::DISK_PARTITION_ZERO_SIZE };
BEGIN{$TYPEINFO{DISK_CHANGE_READONLY}=["function", "integer"]}
*DISK_CHANGE_READONLY = sub { $LibStoragec::DISK_CHANGE_READONLY };
BEGIN{$TYPEINFO{DISK_RESIZE_PARTITION_INVALID_VOLUME}=["function", "integer"]}
*DISK_RESIZE_PARTITION_INVALID_VOLUME = sub { $LibStoragec::DISK_RESIZE_PARTITION_INVALID_VOLUME };
BEGIN{$TYPEINFO{DISK_RESIZE_PARTITION_PARTED_FAILED}=["function", "integer"]}
*DISK_RESIZE_PARTITION_PARTED_FAILED = sub { $LibStoragec::DISK_RESIZE_PARTITION_PARTED_FAILED };
BEGIN{$TYPEINFO{DISK_RESIZE_NO_SPACE}=["function", "integer"]}
*DISK_RESIZE_NO_SPACE = sub { $LibStoragec::DISK_RESIZE_NO_SPACE };
BEGIN{$TYPEINFO{DISK_CHECK_RESIZE_INVALID_VOLUME}=["function", "integer"]}
*DISK_CHECK_RESIZE_INVALID_VOLUME = sub { $LibStoragec::DISK_CHECK_RESIZE_INVALID_VOLUME };
BEGIN{$TYPEINFO{DISK_REMOVE_PARTITION_CREATE_NOT_FOUND}=["function", "integer"]}
*DISK_REMOVE_PARTITION_CREATE_NOT_FOUND = sub { $LibStoragec::DISK_REMOVE_PARTITION_CREATE_NOT_FOUND };
BEGIN{$TYPEINFO{DISK_COMMIT_NOTHING_TODO}=["function", "integer"]}
*DISK_COMMIT_NOTHING_TODO = sub { $LibStoragec::DISK_COMMIT_NOTHING_TODO };
BEGIN{$TYPEINFO{DISK_CREATE_PARTITION_NO_SPACE}=["function", "integer"]}
*DISK_CREATE_PARTITION_NO_SPACE = sub { $LibStoragec::DISK_CREATE_PARTITION_NO_SPACE };
BEGIN{$TYPEINFO{DISK_REMOVE_USED_BY}=["function", "integer"]}
*DISK_REMOVE_USED_BY = sub { $LibStoragec::DISK_REMOVE_USED_BY };
BEGIN{$TYPEINFO{DISK_INIT_NOT_POSSIBLE}=["function", "integer"]}
*DISK_INIT_NOT_POSSIBLE = sub { $LibStoragec::DISK_INIT_NOT_POSSIBLE };
BEGIN{$TYPEINFO{DISK_INVALID_PARTITION_ID}=["function", "integer"]}
*DISK_INVALID_PARTITION_ID = sub { $LibStoragec::DISK_INVALID_PARTITION_ID };
BEGIN{$TYPEINFO{STORAGE_DISK_NOT_FOUND}=["function", "integer"]}
*STORAGE_DISK_NOT_FOUND = sub { $LibStoragec::STORAGE_DISK_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_VOLUME_NOT_FOUND}=["function", "integer"]}
*STORAGE_VOLUME_NOT_FOUND = sub { $LibStoragec::STORAGE_VOLUME_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_REMOVE_PARTITION_INVALID_CONTAINER}=["function", "integer"]}
*STORAGE_REMOVE_PARTITION_INVALID_CONTAINER = sub { $LibStoragec::STORAGE_REMOVE_PARTITION_INVALID_CONTAINER };
BEGIN{$TYPEINFO{STORAGE_CHANGE_PARTITION_ID_INVALID_CONTAINER}=["function", "integer"]}
*STORAGE_CHANGE_PARTITION_ID_INVALID_CONTAINER = sub { $LibStoragec::STORAGE_CHANGE_PARTITION_ID_INVALID_CONTAINER };
BEGIN{$TYPEINFO{STORAGE_CHANGE_READONLY}=["function", "integer"]}
*STORAGE_CHANGE_READONLY = sub { $LibStoragec::STORAGE_CHANGE_READONLY };
BEGIN{$TYPEINFO{STORAGE_DISK_USED_BY}=["function", "integer"]}
*STORAGE_DISK_USED_BY = sub { $LibStoragec::STORAGE_DISK_USED_BY };
BEGIN{$TYPEINFO{STORAGE_LVM_VG_EXISTS}=["function", "integer"]}
*STORAGE_LVM_VG_EXISTS = sub { $LibStoragec::STORAGE_LVM_VG_EXISTS };
BEGIN{$TYPEINFO{STORAGE_LVM_VG_NOT_FOUND}=["function", "integer"]}
*STORAGE_LVM_VG_NOT_FOUND = sub { $LibStoragec::STORAGE_LVM_VG_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_LVM_INVALID_DEVICE}=["function", "integer"]}
*STORAGE_LVM_INVALID_DEVICE = sub { $LibStoragec::STORAGE_LVM_INVALID_DEVICE };
BEGIN{$TYPEINFO{STORAGE_CONTAINER_NOT_FOUND}=["function", "integer"]}
*STORAGE_CONTAINER_NOT_FOUND = sub { $LibStoragec::STORAGE_CONTAINER_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_VG_INVALID_NAME}=["function", "integer"]}
*STORAGE_VG_INVALID_NAME = sub { $LibStoragec::STORAGE_VG_INVALID_NAME };
BEGIN{$TYPEINFO{STORAGE_REMOVE_USED_VOLUME}=["function", "integer"]}
*STORAGE_REMOVE_USED_VOLUME = sub { $LibStoragec::STORAGE_REMOVE_USED_VOLUME };
BEGIN{$TYPEINFO{STORAGE_REMOVE_USING_UNKNOWN_TYPE}=["function", "integer"]}
*STORAGE_REMOVE_USING_UNKNOWN_TYPE = sub { $LibStoragec::STORAGE_REMOVE_USING_UNKNOWN_TYPE };
BEGIN{$TYPEINFO{STORAGE_NOT_YET_IMPLEMENTED}=["function", "integer"]}
*STORAGE_NOT_YET_IMPLEMENTED = sub { $LibStoragec::STORAGE_NOT_YET_IMPLEMENTED };
BEGIN{$TYPEINFO{STORAGE_MD_INVALID_NAME}=["function", "integer"]}
*STORAGE_MD_INVALID_NAME = sub { $LibStoragec::STORAGE_MD_INVALID_NAME };
BEGIN{$TYPEINFO{STORAGE_MD_NOT_FOUND}=["function", "integer"]}
*STORAGE_MD_NOT_FOUND = sub { $LibStoragec::STORAGE_MD_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_MEMORY_EXHAUSTED}=["function", "integer"]}
*STORAGE_MEMORY_EXHAUSTED = sub { $LibStoragec::STORAGE_MEMORY_EXHAUSTED };
BEGIN{$TYPEINFO{STORAGE_LOOP_NOT_FOUND}=["function", "integer"]}
*STORAGE_LOOP_NOT_FOUND = sub { $LibStoragec::STORAGE_LOOP_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_CREATED_LOOP_NOT_FOUND}=["function", "integer"]}
*STORAGE_CREATED_LOOP_NOT_FOUND = sub { $LibStoragec::STORAGE_CREATED_LOOP_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_CHANGE_AREA_INVALID_CONTAINER}=["function", "integer"]}
*STORAGE_CHANGE_AREA_INVALID_CONTAINER = sub { $LibStoragec::STORAGE_CHANGE_AREA_INVALID_CONTAINER };
BEGIN{$TYPEINFO{STORAGE_BACKUP_STATE_NOT_FOUND}=["function", "integer"]}
*STORAGE_BACKUP_STATE_NOT_FOUND = sub { $LibStoragec::STORAGE_BACKUP_STATE_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_INVALID_FSTAB_VALUE}=["function", "integer"]}
*STORAGE_INVALID_FSTAB_VALUE = sub { $LibStoragec::STORAGE_INVALID_FSTAB_VALUE };
BEGIN{$TYPEINFO{STORAGE_NO_FSTAB_PTR}=["function", "integer"]}
*STORAGE_NO_FSTAB_PTR = sub { $LibStoragec::STORAGE_NO_FSTAB_PTR };
BEGIN{$TYPEINFO{STORAGE_DEVICE_NODE_NOT_FOUND}=["function", "integer"]}
*STORAGE_DEVICE_NODE_NOT_FOUND = sub { $LibStoragec::STORAGE_DEVICE_NODE_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_DMRAID_CO_NOT_FOUND}=["function", "integer"]}
*STORAGE_DMRAID_CO_NOT_FOUND = sub { $LibStoragec::STORAGE_DMRAID_CO_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_RESIZE_INVALID_CONTAINER}=["function", "integer"]}
*STORAGE_RESIZE_INVALID_CONTAINER = sub { $LibStoragec::STORAGE_RESIZE_INVALID_CONTAINER };
BEGIN{$TYPEINFO{STORAGE_DMMULTIPATH_CO_NOT_FOUND}=["function", "integer"]}
*STORAGE_DMMULTIPATH_CO_NOT_FOUND = sub { $LibStoragec::STORAGE_DMMULTIPATH_CO_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_ZERO_DEVICE_FAILED}=["function", "integer"]}
*STORAGE_ZERO_DEVICE_FAILED = sub { $LibStoragec::STORAGE_ZERO_DEVICE_FAILED };
BEGIN{$TYPEINFO{STORAGE_INVALID_BACKUP_STATE_NAME}=["function", "integer"]}
*STORAGE_INVALID_BACKUP_STATE_NAME = sub { $LibStoragec::STORAGE_INVALID_BACKUP_STATE_NAME };
BEGIN{$TYPEINFO{STORAGE_MDPART_CO_NOT_FOUND}=["function", "integer"]}
*STORAGE_MDPART_CO_NOT_FOUND = sub { $LibStoragec::STORAGE_MDPART_CO_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_DEVICE_NOT_FOUND}=["function", "integer"]}
*STORAGE_DEVICE_NOT_FOUND = sub { $LibStoragec::STORAGE_DEVICE_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_BTRFS_CO_NOT_FOUND}=["function", "integer"]}
*STORAGE_BTRFS_CO_NOT_FOUND = sub { $LibStoragec::STORAGE_BTRFS_CO_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_TMPFS_CO_NOT_FOUND}=["function", "integer"]}
*STORAGE_TMPFS_CO_NOT_FOUND = sub { $LibStoragec::STORAGE_TMPFS_CO_NOT_FOUND };
BEGIN{$TYPEINFO{STORAGE_VOLUME_NOT_ENCRYPTED}=["function", "integer"]}
*STORAGE_VOLUME_NOT_ENCRYPTED = sub { $LibStoragec::STORAGE_VOLUME_NOT_ENCRYPTED };
BEGIN{$TYPEINFO{STORAGE_DM_RENAME_FAILED}=["function", "integer"]}
*STORAGE_DM_RENAME_FAILED = sub { $LibStoragec::STORAGE_DM_RENAME_FAILED };
BEGIN{$TYPEINFO{VOLUME_COMMIT_UNKNOWN_STAGE}=["function", "integer"]}
*VOLUME_COMMIT_UNKNOWN_STAGE = sub { $LibStoragec::VOLUME_COMMIT_UNKNOWN_STAGE };
BEGIN{$TYPEINFO{VOLUME_FSTAB_EMPTY_MOUNT}=["function", "integer"]}
*VOLUME_FSTAB_EMPTY_MOUNT = sub { $LibStoragec::VOLUME_FSTAB_EMPTY_MOUNT };
BEGIN{$TYPEINFO{VOLUME_UMOUNT_FAILED}=["function", "integer"]}
*VOLUME_UMOUNT_FAILED = sub { $LibStoragec::VOLUME_UMOUNT_FAILED };
BEGIN{$TYPEINFO{VOLUME_MOUNT_FAILED}=["function", "integer"]}
*VOLUME_MOUNT_FAILED = sub { $LibStoragec::VOLUME_MOUNT_FAILED };
BEGIN{$TYPEINFO{VOLUME_FORMAT_UNKNOWN_FS}=["function", "integer"]}
*VOLUME_FORMAT_UNKNOWN_FS = sub { $LibStoragec::VOLUME_FORMAT_UNKNOWN_FS };
BEGIN{$TYPEINFO{VOLUME_FORMAT_FS_UNDETECTED}=["function", "integer"]}
*VOLUME_FORMAT_FS_UNDETECTED = sub { $LibStoragec::VOLUME_FORMAT_FS_UNDETECTED };
BEGIN{$TYPEINFO{VOLUME_FORMAT_FS_TOO_SMALL}=["function", "integer"]}
*VOLUME_FORMAT_FS_TOO_SMALL = sub { $LibStoragec::VOLUME_FORMAT_FS_TOO_SMALL };
BEGIN{$TYPEINFO{VOLUME_FORMAT_FAILED}=["function", "integer"]}
*VOLUME_FORMAT_FAILED = sub { $LibStoragec::VOLUME_FORMAT_FAILED };
BEGIN{$TYPEINFO{VOLUME_TUNE2FS_FAILED}=["function", "integer"]}
*VOLUME_TUNE2FS_FAILED = sub { $LibStoragec::VOLUME_TUNE2FS_FAILED };
BEGIN{$TYPEINFO{VOLUME_MKLABEL_FS_UNABLE}=["function", "integer"]}
*VOLUME_MKLABEL_FS_UNABLE = sub { $LibStoragec::VOLUME_MKLABEL_FS_UNABLE };
BEGIN{$TYPEINFO{VOLUME_MKLABEL_FAILED}=["function", "integer"]}
*VOLUME_MKLABEL_FAILED = sub { $LibStoragec::VOLUME_MKLABEL_FAILED };
BEGIN{$TYPEINFO{VOLUME_LOSETUP_NO_LOOP}=["function", "integer"]}
*VOLUME_LOSETUP_NO_LOOP = sub { $LibStoragec::VOLUME_LOSETUP_NO_LOOP };
BEGIN{$TYPEINFO{VOLUME_LOSETUP_FAILED}=["function", "integer"]}
*VOLUME_LOSETUP_FAILED = sub { $LibStoragec::VOLUME_LOSETUP_FAILED };
BEGIN{$TYPEINFO{VOLUME_CRYPT_NO_PWD}=["function", "integer"]}
*VOLUME_CRYPT_NO_PWD = sub { $LibStoragec::VOLUME_CRYPT_NO_PWD };
BEGIN{$TYPEINFO{VOLUME_CRYPT_PWD_TOO_SHORT}=["function", "integer"]}
*VOLUME_CRYPT_PWD_TOO_SHORT = sub { $LibStoragec::VOLUME_CRYPT_PWD_TOO_SHORT };
BEGIN{$TYPEINFO{VOLUME_CRYPT_NOT_DETECTED}=["function", "integer"]}
*VOLUME_CRYPT_NOT_DETECTED = sub { $LibStoragec::VOLUME_CRYPT_NOT_DETECTED };
BEGIN{$TYPEINFO{VOLUME_FORMAT_EXTENDED_UNSUPPORTED}=["function", "integer"]}
*VOLUME_FORMAT_EXTENDED_UNSUPPORTED = sub { $LibStoragec::VOLUME_FORMAT_EXTENDED_UNSUPPORTED };
BEGIN{$TYPEINFO{VOLUME_MOUNT_EXTENDED_UNSUPPORTED}=["function", "integer"]}
*VOLUME_MOUNT_EXTENDED_UNSUPPORTED = sub { $LibStoragec::VOLUME_MOUNT_EXTENDED_UNSUPPORTED };
BEGIN{$TYPEINFO{VOLUME_MOUNT_POINT_INVALID}=["function", "integer"]}
*VOLUME_MOUNT_POINT_INVALID = sub { $LibStoragec::VOLUME_MOUNT_POINT_INVALID };
BEGIN{$TYPEINFO{VOLUME_MOUNTBY_NOT_ENCRYPTED}=["function", "integer"]}
*VOLUME_MOUNTBY_NOT_ENCRYPTED = sub { $LibStoragec::VOLUME_MOUNTBY_NOT_ENCRYPTED };
BEGIN{$TYPEINFO{VOLUME_MOUNTBY_UNSUPPORTED_BY_FS}=["function", "integer"]}
*VOLUME_MOUNTBY_UNSUPPORTED_BY_FS = sub { $LibStoragec::VOLUME_MOUNTBY_UNSUPPORTED_BY_FS };
BEGIN{$TYPEINFO{VOLUME_LABEL_NOT_SUPPORTED}=["function", "integer"]}
*VOLUME_LABEL_NOT_SUPPORTED = sub { $LibStoragec::VOLUME_LABEL_NOT_SUPPORTED };
BEGIN{$TYPEINFO{VOLUME_LABEL_TOO_LONG}=["function", "integer"]}
*VOLUME_LABEL_TOO_LONG = sub { $LibStoragec::VOLUME_LABEL_TOO_LONG };
BEGIN{$TYPEINFO{VOLUME_LABEL_WHILE_MOUNTED}=["function", "integer"]}
*VOLUME_LABEL_WHILE_MOUNTED = sub { $LibStoragec::VOLUME_LABEL_WHILE_MOUNTED };
BEGIN{$TYPEINFO{VOLUME_RESIZE_UNSUPPORTED_BY_FS}=["function", "integer"]}
*VOLUME_RESIZE_UNSUPPORTED_BY_FS = sub { $LibStoragec::VOLUME_RESIZE_UNSUPPORTED_BY_FS };
BEGIN{$TYPEINFO{VOLUME_RESIZE_UNSUPPORTED_BY_CONTAINER}=["function", "integer"]}
*VOLUME_RESIZE_UNSUPPORTED_BY_CONTAINER = sub { $LibStoragec::VOLUME_RESIZE_UNSUPPORTED_BY_CONTAINER };
BEGIN{$TYPEINFO{VOLUME_RESIZE_FAILED}=["function", "integer"]}
*VOLUME_RESIZE_FAILED = sub { $LibStoragec::VOLUME_RESIZE_FAILED };
BEGIN{$TYPEINFO{VOLUME_ALREADY_IN_USE}=["function", "integer"]}
*VOLUME_ALREADY_IN_USE = sub { $LibStoragec::VOLUME_ALREADY_IN_USE };
BEGIN{$TYPEINFO{VOLUME_LOUNSETUP_FAILED}=["function", "integer"]}
*VOLUME_LOUNSETUP_FAILED = sub { $LibStoragec::VOLUME_LOUNSETUP_FAILED };
BEGIN{$TYPEINFO{VOLUME_DEVICE_NOT_PRESENT}=["function", "integer"]}
*VOLUME_DEVICE_NOT_PRESENT = sub { $LibStoragec::VOLUME_DEVICE_NOT_PRESENT };
BEGIN{$TYPEINFO{VOLUME_DEVICE_NOT_BLOCK}=["function", "integer"]}
*VOLUME_DEVICE_NOT_BLOCK = sub { $LibStoragec::VOLUME_DEVICE_NOT_BLOCK };
BEGIN{$TYPEINFO{VOLUME_MOUNTBY_UNSUPPORTED_BY_VOLUME}=["function", "integer"]}
*VOLUME_MOUNTBY_UNSUPPORTED_BY_VOLUME = sub { $LibStoragec::VOLUME_MOUNTBY_UNSUPPORTED_BY_VOLUME };
BEGIN{$TYPEINFO{VOLUME_CRYPTFORMAT_FAILED}=["function", "integer"]}
*VOLUME_CRYPTFORMAT_FAILED = sub { $LibStoragec::VOLUME_CRYPTFORMAT_FAILED };
BEGIN{$TYPEINFO{VOLUME_CRYPTSETUP_FAILED}=["function", "integer"]}
*VOLUME_CRYPTSETUP_FAILED = sub { $LibStoragec::VOLUME_CRYPTSETUP_FAILED };
BEGIN{$TYPEINFO{VOLUME_CRYPTUNSETUP_FAILED}=["function", "integer"]}
*VOLUME_CRYPTUNSETUP_FAILED = sub { $LibStoragec::VOLUME_CRYPTUNSETUP_FAILED };
BEGIN{$TYPEINFO{VOLUME_FORMAT_NOT_IMPLEMENTED}=["function", "integer"]}
*VOLUME_FORMAT_NOT_IMPLEMENTED = sub { $LibStoragec::VOLUME_FORMAT_NOT_IMPLEMENTED };
BEGIN{$TYPEINFO{VOLUME_FORMAT_IMPOSSIBLE}=["function", "integer"]}
*VOLUME_FORMAT_IMPOSSIBLE = sub { $LibStoragec::VOLUME_FORMAT_IMPOSSIBLE };
BEGIN{$TYPEINFO{VOLUME_CRYPT_NFS_IMPOSSIBLE}=["function", "integer"]}
*VOLUME_CRYPT_NFS_IMPOSSIBLE = sub { $LibStoragec::VOLUME_CRYPT_NFS_IMPOSSIBLE };
BEGIN{$TYPEINFO{VOLUME_REMOUNT_FAILED}=["function", "integer"]}
*VOLUME_REMOUNT_FAILED = sub { $LibStoragec::VOLUME_REMOUNT_FAILED };
BEGIN{$TYPEINFO{VOLUME_TUNEREISERFS_FAILED}=["function", "integer"]}
*VOLUME_TUNEREISERFS_FAILED = sub { $LibStoragec::VOLUME_TUNEREISERFS_FAILED };
BEGIN{$TYPEINFO{VOLUME_UMOUNT_NOT_MOUNTED}=["function", "integer"]}
*VOLUME_UMOUNT_NOT_MOUNTED = sub { $LibStoragec::VOLUME_UMOUNT_NOT_MOUNTED };
BEGIN{$TYPEINFO{VOLUME_BTRFS_ADD_FAILED}=["function", "integer"]}
*VOLUME_BTRFS_ADD_FAILED = sub { $LibStoragec::VOLUME_BTRFS_ADD_FAILED };
BEGIN{$TYPEINFO{VOLUME_CANNOT_TMP_MOUNT}=["function", "integer"]}
*VOLUME_CANNOT_TMP_MOUNT = sub { $LibStoragec::VOLUME_CANNOT_TMP_MOUNT };
BEGIN{$TYPEINFO{VOLUME_CANNOT_TMP_UMOUNT}=["function", "integer"]}
*VOLUME_CANNOT_TMP_UMOUNT = sub { $LibStoragec::VOLUME_CANNOT_TMP_UMOUNT };
BEGIN{$TYPEINFO{VOLUME_BTRFS_SUBVOL_INIT_FAILED}=["function", "integer"]}
*VOLUME_BTRFS_SUBVOL_INIT_FAILED = sub { $LibStoragec::VOLUME_BTRFS_SUBVOL_INIT_FAILED };
BEGIN{$TYPEINFO{VOLUME_BTRFS_SUBVOL_DETDEFAULT}=["function", "integer"]}
*VOLUME_BTRFS_SUBVOL_DETDEFAULT = sub { $LibStoragec::VOLUME_BTRFS_SUBVOL_DETDEFAULT };
BEGIN{$TYPEINFO{LVM_CREATE_PV_FAILED}=["function", "integer"]}
*LVM_CREATE_PV_FAILED = sub { $LibStoragec::LVM_CREATE_PV_FAILED };
BEGIN{$TYPEINFO{LVM_PV_ALREADY_CONTAINED}=["function", "integer"]}
*LVM_PV_ALREADY_CONTAINED = sub { $LibStoragec::LVM_PV_ALREADY_CONTAINED };
BEGIN{$TYPEINFO{LVM_PV_DEVICE_UNKNOWN}=["function", "integer"]}
*LVM_PV_DEVICE_UNKNOWN = sub { $LibStoragec::LVM_PV_DEVICE_UNKNOWN };
BEGIN{$TYPEINFO{LVM_PV_DEVICE_USED}=["function", "integer"]}
*LVM_PV_DEVICE_USED = sub { $LibStoragec::LVM_PV_DEVICE_USED };
BEGIN{$TYPEINFO{LVM_VG_HAS_NONE_PV}=["function", "integer"]}
*LVM_VG_HAS_NONE_PV = sub { $LibStoragec::LVM_VG_HAS_NONE_PV };
BEGIN{$TYPEINFO{LVM_LV_INVALID_NAME}=["function", "integer"]}
*LVM_LV_INVALID_NAME = sub { $LibStoragec::LVM_LV_INVALID_NAME };
BEGIN{$TYPEINFO{LVM_LV_DUPLICATE_NAME}=["function", "integer"]}
*LVM_LV_DUPLICATE_NAME = sub { $LibStoragec::LVM_LV_DUPLICATE_NAME };
BEGIN{$TYPEINFO{LVM_LV_NO_SPACE}=["function", "integer"]}
*LVM_LV_NO_SPACE = sub { $LibStoragec::LVM_LV_NO_SPACE };
BEGIN{$TYPEINFO{LVM_LV_UNKNOWN_NAME}=["function", "integer"]}
*LVM_LV_UNKNOWN_NAME = sub { $LibStoragec::LVM_LV_UNKNOWN_NAME };
BEGIN{$TYPEINFO{LVM_LV_NOT_IN_LIST}=["function", "integer"]}
*LVM_LV_NOT_IN_LIST = sub { $LibStoragec::LVM_LV_NOT_IN_LIST };
BEGIN{$TYPEINFO{LVM_VG_CREATE_FAILED}=["function", "integer"]}
*LVM_VG_CREATE_FAILED = sub { $LibStoragec::LVM_VG_CREATE_FAILED };
BEGIN{$TYPEINFO{LVM_VG_EXTEND_FAILED}=["function", "integer"]}
*LVM_VG_EXTEND_FAILED = sub { $LibStoragec::LVM_VG_EXTEND_FAILED };
BEGIN{$TYPEINFO{LVM_VG_REDUCE_FAILED}=["function", "integer"]}
*LVM_VG_REDUCE_FAILED = sub { $LibStoragec::LVM_VG_REDUCE_FAILED };
BEGIN{$TYPEINFO{LVM_VG_REMOVE_FAILED}=["function", "integer"]}
*LVM_VG_REMOVE_FAILED = sub { $LibStoragec::LVM_VG_REMOVE_FAILED };
BEGIN{$TYPEINFO{LVM_LV_CREATE_FAILED}=["function", "integer"]}
*LVM_LV_CREATE_FAILED = sub { $LibStoragec::LVM_LV_CREATE_FAILED };
BEGIN{$TYPEINFO{LVM_LV_REMOVE_FAILED}=["function", "integer"]}
*LVM_LV_REMOVE_FAILED = sub { $LibStoragec::LVM_LV_REMOVE_FAILED };
BEGIN{$TYPEINFO{LVM_LV_RESIZE_FAILED}=["function", "integer"]}
*LVM_LV_RESIZE_FAILED = sub { $LibStoragec::LVM_LV_RESIZE_FAILED };
BEGIN{$TYPEINFO{LVM_PV_STILL_ADDED}=["function", "integer"]}
*LVM_PV_STILL_ADDED = sub { $LibStoragec::LVM_PV_STILL_ADDED };
BEGIN{$TYPEINFO{LVM_PV_REMOVE_NOT_FOUND}=["function", "integer"]}
*LVM_PV_REMOVE_NOT_FOUND = sub { $LibStoragec::LVM_PV_REMOVE_NOT_FOUND };
BEGIN{$TYPEINFO{LVM_CREATE_LV_INVALID_VOLUME}=["function", "integer"]}
*LVM_CREATE_LV_INVALID_VOLUME = sub { $LibStoragec::LVM_CREATE_LV_INVALID_VOLUME };
BEGIN{$TYPEINFO{LVM_REMOVE_LV_INVALID_VOLUME}=["function", "integer"]}
*LVM_REMOVE_LV_INVALID_VOLUME = sub { $LibStoragec::LVM_REMOVE_LV_INVALID_VOLUME };
BEGIN{$TYPEINFO{LVM_RESIZE_LV_INVALID_VOLUME}=["function", "integer"]}
*LVM_RESIZE_LV_INVALID_VOLUME = sub { $LibStoragec::LVM_RESIZE_LV_INVALID_VOLUME };
BEGIN{$TYPEINFO{LVM_CHANGE_READONLY}=["function", "integer"]}
*LVM_CHANGE_READONLY = sub { $LibStoragec::LVM_CHANGE_READONLY };
BEGIN{$TYPEINFO{LVM_CHECK_RESIZE_INVALID_VOLUME}=["function", "integer"]}
*LVM_CHECK_RESIZE_INVALID_VOLUME = sub { $LibStoragec::LVM_CHECK_RESIZE_INVALID_VOLUME };
BEGIN{$TYPEINFO{LVM_COMMIT_NOTHING_TODO}=["function", "integer"]}
*LVM_COMMIT_NOTHING_TODO = sub { $LibStoragec::LVM_COMMIT_NOTHING_TODO };
BEGIN{$TYPEINFO{LVM_LV_REMOVE_USED_BY}=["function", "integer"]}
*LVM_LV_REMOVE_USED_BY = sub { $LibStoragec::LVM_LV_REMOVE_USED_BY };
BEGIN{$TYPEINFO{LVM_LV_ALREADY_ON_DISK}=["function", "integer"]}
*LVM_LV_ALREADY_ON_DISK = sub { $LibStoragec::LVM_LV_ALREADY_ON_DISK };
BEGIN{$TYPEINFO{LVM_LV_NO_STRIPE_SIZE}=["function", "integer"]}
*LVM_LV_NO_STRIPE_SIZE = sub { $LibStoragec::LVM_LV_NO_STRIPE_SIZE };
BEGIN{$TYPEINFO{LVM_LV_UNKNOWN_ORIGIN}=["function", "integer"]}
*LVM_LV_UNKNOWN_ORIGIN = sub { $LibStoragec::LVM_LV_UNKNOWN_ORIGIN };
BEGIN{$TYPEINFO{LVM_LV_NOT_ON_DISK}=["function", "integer"]}
*LVM_LV_NOT_ON_DISK = sub { $LibStoragec::LVM_LV_NOT_ON_DISK };
BEGIN{$TYPEINFO{LVM_LV_NOT_SNAPSHOT}=["function", "integer"]}
*LVM_LV_NOT_SNAPSHOT = sub { $LibStoragec::LVM_LV_NOT_SNAPSHOT };
BEGIN{$TYPEINFO{LVM_LV_HAS_SNAPSHOTS}=["function", "integer"]}
*LVM_LV_HAS_SNAPSHOTS = sub { $LibStoragec::LVM_LV_HAS_SNAPSHOTS };
BEGIN{$TYPEINFO{LVM_LV_IS_SNAPSHOT}=["function", "integer"]}
*LVM_LV_IS_SNAPSHOT = sub { $LibStoragec::LVM_LV_IS_SNAPSHOT };
BEGIN{$TYPEINFO{LVM_LIST_EMPTY}=["function", "integer"]}
*LVM_LIST_EMPTY = sub { $LibStoragec::LVM_LIST_EMPTY };
BEGIN{$TYPEINFO{LVM_LV_NO_POOL_OR_SNAP}=["function", "integer"]}
*LVM_LV_NO_POOL_OR_SNAP = sub { $LibStoragec::LVM_LV_NO_POOL_OR_SNAP };
BEGIN{$TYPEINFO{LVM_LV_NO_POOL}=["function", "integer"]}
*LVM_LV_NO_POOL = sub { $LibStoragec::LVM_LV_NO_POOL };
BEGIN{$TYPEINFO{LVM_LV_UNKNOWN_POOL}=["function", "integer"]}
*LVM_LV_UNKNOWN_POOL = sub { $LibStoragec::LVM_LV_UNKNOWN_POOL };
BEGIN{$TYPEINFO{LVM_LV_INVALID_CHUNK_SIZE}=["function", "integer"]}
*LVM_LV_INVALID_CHUNK_SIZE = sub { $LibStoragec::LVM_LV_INVALID_CHUNK_SIZE };
BEGIN{$TYPEINFO{LVM_LV_POOL_NO_FORMAT}=["function", "integer"]}
*LVM_LV_POOL_NO_FORMAT = sub { $LibStoragec::LVM_LV_POOL_NO_FORMAT };
BEGIN{$TYPEINFO{LVM_LV_POOL_NO_MOUNT}=["function", "integer"]}
*LVM_LV_POOL_NO_MOUNT = sub { $LibStoragec::LVM_LV_POOL_NO_MOUNT };
BEGIN{$TYPEINFO{FSTAB_ENTRY_NOT_FOUND}=["function", "integer"]}
*FSTAB_ENTRY_NOT_FOUND = sub { $LibStoragec::FSTAB_ENTRY_NOT_FOUND };
BEGIN{$TYPEINFO{FSTAB_CHANGE_PREFIX_IMPOSSIBLE}=["function", "integer"]}
*FSTAB_CHANGE_PREFIX_IMPOSSIBLE = sub { $LibStoragec::FSTAB_CHANGE_PREFIX_IMPOSSIBLE };
BEGIN{$TYPEINFO{FSTAB_REMOVE_ENTRY_NOT_FOUND}=["function", "integer"]}
*FSTAB_REMOVE_ENTRY_NOT_FOUND = sub { $LibStoragec::FSTAB_REMOVE_ENTRY_NOT_FOUND };
BEGIN{$TYPEINFO{FSTAB_UPDATE_ENTRY_NOT_FOUND}=["function", "integer"]}
*FSTAB_UPDATE_ENTRY_NOT_FOUND = sub { $LibStoragec::FSTAB_UPDATE_ENTRY_NOT_FOUND };
BEGIN{$TYPEINFO{FSTAB_ADD_ENTRY_FOUND}=["function", "integer"]}
*FSTAB_ADD_ENTRY_FOUND = sub { $LibStoragec::FSTAB_ADD_ENTRY_FOUND };
BEGIN{$TYPEINFO{MD_CHANGE_READONLY}=["function", "integer"]}
*MD_CHANGE_READONLY = sub { $LibStoragec::MD_CHANGE_READONLY };
BEGIN{$TYPEINFO{MD_DUPLICATE_NUMBER}=["function", "integer"]}
*MD_DUPLICATE_NUMBER = sub { $LibStoragec::MD_DUPLICATE_NUMBER };
BEGIN{$TYPEINFO{MD_TOO_FEW_DEVICES}=["function", "integer"]}
*MD_TOO_FEW_DEVICES = sub { $LibStoragec::MD_TOO_FEW_DEVICES };
BEGIN{$TYPEINFO{MD_DEVICE_UNKNOWN}=["function", "integer"]}
*MD_DEVICE_UNKNOWN = sub { $LibStoragec::MD_DEVICE_UNKNOWN };
BEGIN{$TYPEINFO{MD_DEVICE_USED}=["function", "integer"]}
*MD_DEVICE_USED = sub { $LibStoragec::MD_DEVICE_USED };
BEGIN{$TYPEINFO{MD_CREATE_INVALID_VOLUME}=["function", "integer"]}
*MD_CREATE_INVALID_VOLUME = sub { $LibStoragec::MD_CREATE_INVALID_VOLUME };
BEGIN{$TYPEINFO{MD_REMOVE_FAILED}=["function", "integer"]}
*MD_REMOVE_FAILED = sub { $LibStoragec::MD_REMOVE_FAILED };
BEGIN{$TYPEINFO{MD_NOT_IN_LIST}=["function", "integer"]}
*MD_NOT_IN_LIST = sub { $LibStoragec::MD_NOT_IN_LIST };
BEGIN{$TYPEINFO{MD_CREATE_FAILED}=["function", "integer"]}
*MD_CREATE_FAILED = sub { $LibStoragec::MD_CREATE_FAILED };
BEGIN{$TYPEINFO{MD_UNKNOWN_NUMBER}=["function", "integer"]}
*MD_UNKNOWN_NUMBER = sub { $LibStoragec::MD_UNKNOWN_NUMBER };
BEGIN{$TYPEINFO{MD_REMOVE_USED_BY}=["function", "integer"]}
*MD_REMOVE_USED_BY = sub { $LibStoragec::MD_REMOVE_USED_BY };
BEGIN{$TYPEINFO{MD_NUMBER_TOO_LARGE}=["function", "integer"]}
*MD_NUMBER_TOO_LARGE = sub { $LibStoragec::MD_NUMBER_TOO_LARGE };
BEGIN{$TYPEINFO{MD_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*MD_REMOVE_INVALID_VOLUME = sub { $LibStoragec::MD_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{MD_REMOVE_CREATE_NOT_FOUND}=["function", "integer"]}
*MD_REMOVE_CREATE_NOT_FOUND = sub { $LibStoragec::MD_REMOVE_CREATE_NOT_FOUND };
BEGIN{$TYPEINFO{MD_NO_RESIZE_ON_DISK}=["function", "integer"]}
*MD_NO_RESIZE_ON_DISK = sub { $LibStoragec::MD_NO_RESIZE_ON_DISK };
BEGIN{$TYPEINFO{MD_ADD_DUPLICATE}=["function", "integer"]}
*MD_ADD_DUPLICATE = sub { $LibStoragec::MD_ADD_DUPLICATE };
BEGIN{$TYPEINFO{MD_REMOVE_NONEXISTENT}=["function", "integer"]}
*MD_REMOVE_NONEXISTENT = sub { $LibStoragec::MD_REMOVE_NONEXISTENT };
BEGIN{$TYPEINFO{MD_NO_CHANGE_ON_DISK}=["function", "integer"]}
*MD_NO_CHANGE_ON_DISK = sub { $LibStoragec::MD_NO_CHANGE_ON_DISK };
BEGIN{$TYPEINFO{MD_NO_CREATE_UNKNOWN}=["function", "integer"]}
*MD_NO_CREATE_UNKNOWN = sub { $LibStoragec::MD_NO_CREATE_UNKNOWN };
BEGIN{$TYPEINFO{MD_STATE_NOT_ON_DISK}=["function", "integer"]}
*MD_STATE_NOT_ON_DISK = sub { $LibStoragec::MD_STATE_NOT_ON_DISK };
BEGIN{$TYPEINFO{MD_PARTITION_NOT_FOUND}=["function", "integer"]}
*MD_PARTITION_NOT_FOUND = sub { $LibStoragec::MD_PARTITION_NOT_FOUND };
BEGIN{$TYPEINFO{MD_INVALID_PARITY}=["function", "integer"]}
*MD_INVALID_PARITY = sub { $LibStoragec::MD_INVALID_PARITY };
BEGIN{$TYPEINFO{MD_TOO_MANY_SPARES}=["function", "integer"]}
*MD_TOO_MANY_SPARES = sub { $LibStoragec::MD_TOO_MANY_SPARES };
BEGIN{$TYPEINFO{MD_GET_STATE_FAILED}=["function", "integer"]}
*MD_GET_STATE_FAILED = sub { $LibStoragec::MD_GET_STATE_FAILED };
BEGIN{$TYPEINFO{MDPART_CHANGE_READONLY}=["function", "integer"]}
*MDPART_CHANGE_READONLY = sub { $LibStoragec::MDPART_CHANGE_READONLY };
BEGIN{$TYPEINFO{MDPART_INTERNAL_ERR}=["function", "integer"]}
*MDPART_INTERNAL_ERR = sub { $LibStoragec::MDPART_INTERNAL_ERR };
BEGIN{$TYPEINFO{MDPART_INVALID_VOLUME}=["function", "integer"]}
*MDPART_INVALID_VOLUME = sub { $LibStoragec::MDPART_INVALID_VOLUME };
BEGIN{$TYPEINFO{MDPART_PARTITION_NOT_FOUND}=["function", "integer"]}
*MDPART_PARTITION_NOT_FOUND = sub { $LibStoragec::MDPART_PARTITION_NOT_FOUND };
BEGIN{$TYPEINFO{MDPART_REMOVE_PARTITION_LIST_ERASE}=["function", "integer"]}
*MDPART_REMOVE_PARTITION_LIST_ERASE = sub { $LibStoragec::MDPART_REMOVE_PARTITION_LIST_ERASE };
BEGIN{$TYPEINFO{MDPART_COMMIT_NOTHING_TODO}=["function", "integer"]}
*MDPART_COMMIT_NOTHING_TODO = sub { $LibStoragec::MDPART_COMMIT_NOTHING_TODO };
BEGIN{$TYPEINFO{MDPART_NO_REMOVE}=["function", "integer"]}
*MDPART_NO_REMOVE = sub { $LibStoragec::MDPART_NO_REMOVE };
BEGIN{$TYPEINFO{MDPART_DEVICE_NOT_FOUND}=["function", "integer"]}
*MDPART_DEVICE_NOT_FOUND = sub { $LibStoragec::MDPART_DEVICE_NOT_FOUND };
BEGIN{$TYPEINFO{LOOP_CHANGE_READONLY}=["function", "integer"]}
*LOOP_CHANGE_READONLY = sub { $LibStoragec::LOOP_CHANGE_READONLY };
BEGIN{$TYPEINFO{LOOP_DUPLICATE_FILE}=["function", "integer"]}
*LOOP_DUPLICATE_FILE = sub { $LibStoragec::LOOP_DUPLICATE_FILE };
BEGIN{$TYPEINFO{LOOP_UNKNOWN_FILE}=["function", "integer"]}
*LOOP_UNKNOWN_FILE = sub { $LibStoragec::LOOP_UNKNOWN_FILE };
BEGIN{$TYPEINFO{LOOP_REMOVE_USED_BY}=["function", "integer"]}
*LOOP_REMOVE_USED_BY = sub { $LibStoragec::LOOP_REMOVE_USED_BY };
BEGIN{$TYPEINFO{LOOP_FILE_CREATE_FAILED}=["function", "integer"]}
*LOOP_FILE_CREATE_FAILED = sub { $LibStoragec::LOOP_FILE_CREATE_FAILED };
BEGIN{$TYPEINFO{LOOP_CREATE_INVALID_VOLUME}=["function", "integer"]}
*LOOP_CREATE_INVALID_VOLUME = sub { $LibStoragec::LOOP_CREATE_INVALID_VOLUME };
BEGIN{$TYPEINFO{LOOP_REMOVE_FILE_FAILED}=["function", "integer"]}
*LOOP_REMOVE_FILE_FAILED = sub { $LibStoragec::LOOP_REMOVE_FILE_FAILED };
BEGIN{$TYPEINFO{LOOP_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*LOOP_REMOVE_INVALID_VOLUME = sub { $LibStoragec::LOOP_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{LOOP_NOT_IN_LIST}=["function", "integer"]}
*LOOP_NOT_IN_LIST = sub { $LibStoragec::LOOP_NOT_IN_LIST };
BEGIN{$TYPEINFO{LOOP_REMOVE_CREATE_NOT_FOUND}=["function", "integer"]}
*LOOP_REMOVE_CREATE_NOT_FOUND = sub { $LibStoragec::LOOP_REMOVE_CREATE_NOT_FOUND };
BEGIN{$TYPEINFO{LOOP_MODIFY_EXISTING}=["function", "integer"]}
*LOOP_MODIFY_EXISTING = sub { $LibStoragec::LOOP_MODIFY_EXISTING };
BEGIN{$TYPEINFO{PEC_PE_SIZE_INVALID}=["function", "integer"]}
*PEC_PE_SIZE_INVALID = sub { $LibStoragec::PEC_PE_SIZE_INVALID };
BEGIN{$TYPEINFO{PEC_PV_NOT_FOUND}=["function", "integer"]}
*PEC_PV_NOT_FOUND = sub { $LibStoragec::PEC_PV_NOT_FOUND };
BEGIN{$TYPEINFO{PEC_REMOVE_PV_IN_USE}=["function", "integer"]}
*PEC_REMOVE_PV_IN_USE = sub { $LibStoragec::PEC_REMOVE_PV_IN_USE };
BEGIN{$TYPEINFO{PEC_REMOVE_PV_SIZE_NEEDED}=["function", "integer"]}
*PEC_REMOVE_PV_SIZE_NEEDED = sub { $LibStoragec::PEC_REMOVE_PV_SIZE_NEEDED };
BEGIN{$TYPEINFO{PEC_LV_NO_SPACE_STRIPED}=["function", "integer"]}
*PEC_LV_NO_SPACE_STRIPED = sub { $LibStoragec::PEC_LV_NO_SPACE_STRIPED };
BEGIN{$TYPEINFO{PEC_LV_NO_SPACE_SINGLE}=["function", "integer"]}
*PEC_LV_NO_SPACE_SINGLE = sub { $LibStoragec::PEC_LV_NO_SPACE_SINGLE };
BEGIN{$TYPEINFO{PEC_LV_PE_DEV_NOT_FOUND}=["function", "integer"]}
*PEC_LV_PE_DEV_NOT_FOUND = sub { $LibStoragec::PEC_LV_PE_DEV_NOT_FOUND };
BEGIN{$TYPEINFO{DM_CHANGE_READONLY}=["function", "integer"]}
*DM_CHANGE_READONLY = sub { $LibStoragec::DM_CHANGE_READONLY };
BEGIN{$TYPEINFO{DM_UNKNOWN_TABLE}=["function", "integer"]}
*DM_UNKNOWN_TABLE = sub { $LibStoragec::DM_UNKNOWN_TABLE };
BEGIN{$TYPEINFO{DM_REMOVE_USED_BY}=["function", "integer"]}
*DM_REMOVE_USED_BY = sub { $LibStoragec::DM_REMOVE_USED_BY };
BEGIN{$TYPEINFO{DM_REMOVE_CREATE_NOT_FOUND}=["function", "integer"]}
*DM_REMOVE_CREATE_NOT_FOUND = sub { $LibStoragec::DM_REMOVE_CREATE_NOT_FOUND };
BEGIN{$TYPEINFO{DM_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*DM_REMOVE_INVALID_VOLUME = sub { $LibStoragec::DM_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{DM_REMOVE_FAILED}=["function", "integer"]}
*DM_REMOVE_FAILED = sub { $LibStoragec::DM_REMOVE_FAILED };
BEGIN{$TYPEINFO{DM_NOT_IN_LIST}=["function", "integer"]}
*DM_NOT_IN_LIST = sub { $LibStoragec::DM_NOT_IN_LIST };
BEGIN{$TYPEINFO{DASD_NOT_POSSIBLE}=["function", "integer"]}
*DASD_NOT_POSSIBLE = sub { $LibStoragec::DASD_NOT_POSSIBLE };
BEGIN{$TYPEINFO{DASD_FDASD_FAILED}=["function", "integer"]}
*DASD_FDASD_FAILED = sub { $LibStoragec::DASD_FDASD_FAILED };
BEGIN{$TYPEINFO{DASD_DASDFMT_FAILED}=["function", "integer"]}
*DASD_DASDFMT_FAILED = sub { $LibStoragec::DASD_DASDFMT_FAILED };
BEGIN{$TYPEINFO{DMPART_CHANGE_READONLY}=["function", "integer"]}
*DMPART_CHANGE_READONLY = sub { $LibStoragec::DMPART_CHANGE_READONLY };
BEGIN{$TYPEINFO{DMPART_INTERNAL_ERR}=["function", "integer"]}
*DMPART_INTERNAL_ERR = sub { $LibStoragec::DMPART_INTERNAL_ERR };
BEGIN{$TYPEINFO{DMPART_INVALID_VOLUME}=["function", "integer"]}
*DMPART_INVALID_VOLUME = sub { $LibStoragec::DMPART_INVALID_VOLUME };
BEGIN{$TYPEINFO{DMPART_PARTITION_NOT_FOUND}=["function", "integer"]}
*DMPART_PARTITION_NOT_FOUND = sub { $LibStoragec::DMPART_PARTITION_NOT_FOUND };
BEGIN{$TYPEINFO{DMPART_REMOVE_PARTITION_LIST_ERASE}=["function", "integer"]}
*DMPART_REMOVE_PARTITION_LIST_ERASE = sub { $LibStoragec::DMPART_REMOVE_PARTITION_LIST_ERASE };
BEGIN{$TYPEINFO{DMPART_COMMIT_NOTHING_TODO}=["function", "integer"]}
*DMPART_COMMIT_NOTHING_TODO = sub { $LibStoragec::DMPART_COMMIT_NOTHING_TODO };
BEGIN{$TYPEINFO{DMPART_NO_REMOVE}=["function", "integer"]}
*DMPART_NO_REMOVE = sub { $LibStoragec::DMPART_NO_REMOVE };
BEGIN{$TYPEINFO{DMRAID_REMOVE_FAILED}=["function", "integer"]}
*DMRAID_REMOVE_FAILED = sub { $LibStoragec::DMRAID_REMOVE_FAILED };
BEGIN{$TYPEINFO{NFS_VOLUME_NOT_FOUND}=["function", "integer"]}
*NFS_VOLUME_NOT_FOUND = sub { $LibStoragec::NFS_VOLUME_NOT_FOUND };
BEGIN{$TYPEINFO{NFS_CHANGE_READONLY}=["function", "integer"]}
*NFS_CHANGE_READONLY = sub { $LibStoragec::NFS_CHANGE_READONLY };
BEGIN{$TYPEINFO{NFS_REMOVE_VOLUME_CREATE_NOT_FOUND}=["function", "integer"]}
*NFS_REMOVE_VOLUME_CREATE_NOT_FOUND = sub { $LibStoragec::NFS_REMOVE_VOLUME_CREATE_NOT_FOUND };
BEGIN{$TYPEINFO{NFS_REMOVE_VOLUME_LIST_ERASE}=["function", "integer"]}
*NFS_REMOVE_VOLUME_LIST_ERASE = sub { $LibStoragec::NFS_REMOVE_VOLUME_LIST_ERASE };
BEGIN{$TYPEINFO{NFS_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*NFS_REMOVE_INVALID_VOLUME = sub { $LibStoragec::NFS_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{BTRFS_COMMIT_INVALID_VOLUME}=["function", "integer"]}
*BTRFS_COMMIT_INVALID_VOLUME = sub { $LibStoragec::BTRFS_COMMIT_INVALID_VOLUME };
BEGIN{$TYPEINFO{BTRFS_CANNOT_TMP_MOUNT}=["function", "integer"]}
*BTRFS_CANNOT_TMP_MOUNT = sub { $LibStoragec::BTRFS_CANNOT_TMP_MOUNT };
BEGIN{$TYPEINFO{BTRFS_CANNOT_TMP_UMOUNT}=["function", "integer"]}
*BTRFS_CANNOT_TMP_UMOUNT = sub { $LibStoragec::BTRFS_CANNOT_TMP_UMOUNT };
BEGIN{$TYPEINFO{BTRFS_DELETE_SUBVOL_FAIL}=["function", "integer"]}
*BTRFS_DELETE_SUBVOL_FAIL = sub { $LibStoragec::BTRFS_DELETE_SUBVOL_FAIL };
BEGIN{$TYPEINFO{BTRFS_CREATE_SUBVOL_FAIL}=["function", "integer"]}
*BTRFS_CREATE_SUBVOL_FAIL = sub { $LibStoragec::BTRFS_CREATE_SUBVOL_FAIL };
BEGIN{$TYPEINFO{BTRFS_VOLUME_NOT_FOUND}=["function", "integer"]}
*BTRFS_VOLUME_NOT_FOUND = sub { $LibStoragec::BTRFS_VOLUME_NOT_FOUND };
BEGIN{$TYPEINFO{BTRFS_SUBVOL_EXISTS}=["function", "integer"]}
*BTRFS_SUBVOL_EXISTS = sub { $LibStoragec::BTRFS_SUBVOL_EXISTS };
BEGIN{$TYPEINFO{BTRFS_SUBVOL_NON_EXISTS}=["function", "integer"]}
*BTRFS_SUBVOL_NON_EXISTS = sub { $LibStoragec::BTRFS_SUBVOL_NON_EXISTS };
BEGIN{$TYPEINFO{BTRFS_REMOVE_NOT_FOUND}=["function", "integer"]}
*BTRFS_REMOVE_NOT_FOUND = sub { $LibStoragec::BTRFS_REMOVE_NOT_FOUND };
BEGIN{$TYPEINFO{BTRFS_REMOVE_NO_BTRFS}=["function", "integer"]}
*BTRFS_REMOVE_NO_BTRFS = sub { $LibStoragec::BTRFS_REMOVE_NO_BTRFS };
BEGIN{$TYPEINFO{BTRFS_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*BTRFS_REMOVE_INVALID_VOLUME = sub { $LibStoragec::BTRFS_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{BTRFS_CHANGE_READONLY}=["function", "integer"]}
*BTRFS_CHANGE_READONLY = sub { $LibStoragec::BTRFS_CHANGE_READONLY };
BEGIN{$TYPEINFO{BTRFS_DEV_ALREADY_CONTAINED}=["function", "integer"]}
*BTRFS_DEV_ALREADY_CONTAINED = sub { $LibStoragec::BTRFS_DEV_ALREADY_CONTAINED };
BEGIN{$TYPEINFO{BTRFS_DEVICE_UNKNOWN}=["function", "integer"]}
*BTRFS_DEVICE_UNKNOWN = sub { $LibStoragec::BTRFS_DEVICE_UNKNOWN };
BEGIN{$TYPEINFO{BTRFS_DEVICE_USED}=["function", "integer"]}
*BTRFS_DEVICE_USED = sub { $LibStoragec::BTRFS_DEVICE_USED };
BEGIN{$TYPEINFO{BTRFS_HAS_NONE_DEV}=["function", "integer"]}
*BTRFS_HAS_NONE_DEV = sub { $LibStoragec::BTRFS_HAS_NONE_DEV };
BEGIN{$TYPEINFO{BTRFS_DEV_NOT_FOUND}=["function", "integer"]}
*BTRFS_DEV_NOT_FOUND = sub { $LibStoragec::BTRFS_DEV_NOT_FOUND };
BEGIN{$TYPEINFO{BTRFS_EXTEND_FAIL}=["function", "integer"]}
*BTRFS_EXTEND_FAIL = sub { $LibStoragec::BTRFS_EXTEND_FAIL };
BEGIN{$TYPEINFO{BTRFS_REDUCE_FAIL}=["function", "integer"]}
*BTRFS_REDUCE_FAIL = sub { $LibStoragec::BTRFS_REDUCE_FAIL };
BEGIN{$TYPEINFO{BTRFS_LIST_EMPTY}=["function", "integer"]}
*BTRFS_LIST_EMPTY = sub { $LibStoragec::BTRFS_LIST_EMPTY };
BEGIN{$TYPEINFO{BTRFS_RESIZE_INVALID_VOLUME}=["function", "integer"]}
*BTRFS_RESIZE_INVALID_VOLUME = sub { $LibStoragec::BTRFS_RESIZE_INVALID_VOLUME };
BEGIN{$TYPEINFO{BTRFS_MULTIDEV_SHRINK_UNSUPPORTED}=["function", "integer"]}
*BTRFS_MULTIDEV_SHRINK_UNSUPPORTED = sub { $LibStoragec::BTRFS_MULTIDEV_SHRINK_UNSUPPORTED };
BEGIN{$TYPEINFO{TMPFS_REMOVE_INVALID_VOLUME}=["function", "integer"]}
*TMPFS_REMOVE_INVALID_VOLUME = sub { $LibStoragec::TMPFS_REMOVE_INVALID_VOLUME };
BEGIN{$TYPEINFO{TMPFS_REMOVE_NO_TMPFS}=["function", "integer"]}
*TMPFS_REMOVE_NO_TMPFS = sub { $LibStoragec::TMPFS_REMOVE_NO_TMPFS };
BEGIN{$TYPEINFO{TMPFS_REMOVE_NOT_FOUND}=["function", "integer"]}
*TMPFS_REMOVE_NOT_FOUND = sub { $LibStoragec::TMPFS_REMOVE_NOT_FOUND };
BEGIN{$TYPEINFO{CONTAINER_INTERNAL_ERROR}=["function", "integer"]}
*CONTAINER_INTERNAL_ERROR = sub { $LibStoragec::CONTAINER_INTERNAL_ERROR };
BEGIN{$TYPEINFO{CONTAINER_INVALID_VIRTUAL_CALL}=["function", "integer"]}
*CONTAINER_INVALID_VIRTUAL_CALL = sub { $LibStoragec::CONTAINER_INVALID_VIRTUAL_CALL };

1;
